<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Online Modding Suite (MOMS)</title>
    
    <!-- External Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>
    <!-- Three.js - Use latest version with ES modules support -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Create a new object that includes all THREE exports plus OrbitControls
        const THREEWithControls = {
            ...THREE,
            OrbitControls: OrbitControls
        };
        
        // Make it available globally
        window.THREE = THREEWithControls;
        
        // Dispatch event when THREE is ready
        window.dispatchEvent(new Event('threejs-ready'));
        
        console.log('THREE.js modules loaded successfully');
        console.log('THREE available:', !!window.THREE);
        console.log('THREE.OrbitControls available:', !!window.THREE.OrbitControls);
    </script>
    <script>
        // Wait for THREE.js to be ready
        window.addEventListener('threejs-ready', () => {
            console.log('Event: THREE.js ready');
            console.log('THREE available:', !!window.THREE);
            console.log('THREE.OrbitControls available:', !!window.THREE?.OrbitControls);
        });
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Monaco Editor -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script>
    
    <style>
        /* Custom styles */
        .matrix-theme {
            --matrix-green: #00ff00;
            --matrix-dark: #001a00;
            --matrix-black: #000800;
            --matrix-light: #ccffcc;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background-color: var(--matrix-black, #000800);
            color: var(--matrix-green, #00ff00);
        }
        
        .matrix-button {
            background-color: var(--matrix-dark, #001a00);
            color: var(--matrix-green, #00ff00);
            border: 1px solid var(--matrix-green, #00ff00);
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .matrix-button:hover {
            background-color: var(--matrix-green, #00ff00);
            color: var(--matrix-black, #000800);
        }
        
        .file-tree {
            height: calc(100vh - 60px);
            overflow-y: auto;
            background-color: var(--matrix-dark, #001a00);
            border-right: 1px solid var(--matrix-green, #00ff00);
        }
        
        .editor-container {
            height: calc(100vh - 60px);
            overflow: hidden;
            background-color: var(--matrix-black, #000800);
        }
        
        .preview-container {
            height: calc(100vh - 60px);
            overflow: hidden;
            background-color: var(--matrix-dark, #001a00);
            border-left: 1px solid var(--matrix-green, #00ff00);
        }
        
        .file-tree-item {
            padding: 4px 8px;
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 255, 0, 0.1);
        }
        
        .file-tree-item:hover {
            background-color: rgba(0, 255, 0, 0.1);
        }
        
        .file-tree-item.selected {
            background-color: rgba(0, 255, 0, 0.2);
        }
        
        .file-tree-folder {
            font-weight: bold;
        }
        
        .monaco-editor {
            height: 100%;
            width: 100%;
        }
        
        .webgl-container {
            width: 100%;
            height: 100%;
        }
        
        .matrix-header {
            background-color: var(--matrix-dark, #001a00);
            border-bottom: 2px solid var(--matrix-green, #00ff00);
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .matrix-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--matrix-green, #00ff00);
            letter-spacing: 2px;
        }
        
        .loading-matrix {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--matrix-black, #000800);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .loading-text {
            font-size: 24px;
            color: var(--matrix-green, #00ff00);
            margin-top: 20px;
            font-family: 'Courier New', monospace;
        }
        
        .matrix-rain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.5;
        }
        
        /* Tailwind-like utility classes */
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .p-2 { padding: 0.5rem; }
        .p-4 { padding: 1rem; }
        .m-2 { margin: 0.5rem; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .border { border-width: 1px; }
        .rounded { border-radius: 0.25rem; }
        .overflow-hidden { overflow: hidden; }
        .overflow-auto { overflow: auto; }
    </style>
</head>
<body class="matrix-theme">
    <div id="loading" class="loading-matrix">
        <canvas id="matrix-rain" class="matrix-rain"></canvas>
        <div class="loading-text" id="loading-text">Initializing Matrix Online Modding Suite...</div>
    </div>
    
    <div id="root"></div>

    <script type="text/babel">
        // Main React Application
        const { useState, useEffect, useRef } = React;
        
        // File type definitions for Lithtech engine
        const FILE_TYPES = {
            MODEL: {
                extensions: ['.abc', '.moa', '.prop', '.iprf', '.eprf', '.mga', '.mgc'],
                icon: '📊',
                name: 'Model',
                description: 'Matrix Online 3D Model (Characters/Props/Collections)',
                parser: 'parseMOA'
            },
            TEXTURE: {
                extensions: ['.dtx', '.txa', '.txb', '.dds', '.tga', '.png', '.jpg', '.jpeg'],
                icon: '🖼️',
                name: 'Texture',
                description: 'Matrix Online Texture or Image File',
                parser: 'parseTexture'
            },
            LEVEL: {
                extensions: ['.dat', '.world'],
                icon: '🏙️',
                name: 'Level',
                description: 'Lithtech Level Data'
            },
            SOUND: {
                extensions: ['.wav', '.ogg', '.mp3'],
                icon: '🔊',
                name: 'Sound',
                description: 'Audio File'
            },
            CUTSCENE: {
                extensions: ['.bik', '.smk', '.avi', '.mp4'],
                icon: '🎬',
                name: 'Cutscene',
                description: 'Video or Cutscene File',
                parser: 'parseCutscene'
            },
            ANIMATION: {
                extensions: ['.anm', '.ani'],
                icon: '🎭',
                name: 'Animation',
                description: 'Character Animation Data'
            },
            SCRIPT: {
                extensions: ['.lua', '.cs', '.txt', '.py'],
                icon: '📜',
                name: 'Script',
                description: 'Game Script'
            },
            MESSAGE: {
                extensions: ['.msg'],
                icon: '💬',
                name: 'Message',
                description: 'In-Game Text'
            },
            ARCHIVE: {
                extensions: ['.rez', '.lta', '.ltb', '.pkb'],
                icon: '📦',
                name: 'Archive',
                description: 'Lithtech Resource Archive'
            },
            ASSEMBLY: {
                extensions: ['.dll', '.exe'],
                icon: '⚙️',
                name: 'Assembly',
                description: 'Executable or Library File'
            },
            LOG: {
                extensions: ['.log', '.txt', '.out', '.debug'],
                icon: '📋',
                name: 'Log',
                description: 'Log or Debug File'
            },
            OTHER: {
                extensions: [],
                icon: '📄',
                name: 'Other',
                description: 'Unknown File Type'
            }
        };
        
        // Utility functions
        const getFileType = (filename) => {
            if (!filename) return FILE_TYPES.OTHER;
            const ext = '.' + filename.split('.').pop().toLowerCase();
            
            for (const type in FILE_TYPES) {
                if (FILE_TYPES[type].extensions.includes(ext)) {
                    return FILE_TYPES[type];
                }
            }
            
            return FILE_TYPES.OTHER;
        };
        
        // Export model to OBJ format (as mentioned in instructions.txt step 4)
        const exportToOBJ = (mesh) => {
            let objData = `# Exported from Matrix Online Modding Suite (MOMS)\n`;
            objData += `# File generated on ${new Date().toISOString()}\n\n`;
            
            if (!mesh) {
                return objData + `# Error: No mesh data available\n`;
            }
            
            let totalVertices = 0;
            
            // Traverse the mesh to handle both single meshes and groups
            mesh.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const geometry = child.geometry;
                    const position = geometry.attributes.position;
                    const normal = geometry.attributes.normal;
                    const uv = geometry.attributes.uv;
                    const index = geometry.index;
                    
                    if (!position) {
                        objData += `# Warning: Mesh "${child.name || 'unnamed'}" has no position data\n`;
                        return;
                    }
                    
                    objData += `\n# Mesh: ${child.name || 'unnamed'}\n`;
                    objData += `# Vertices: ${position.count}\n`;
                    
                    // Write vertices
                    for (let i = 0; i < position.count; i++) {
                        const x = position.getX(i);
                        const y = position.getY(i);
                        const z = position.getZ(i);
                        objData += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`;
                    }
                    
                    // Write texture coordinates if available
                    if (uv) {
                        objData += `\n# Texture coordinates\n`;
                        for (let i = 0; i < uv.count; i++) {
                            const u = uv.getX(i);
                            const v = uv.getY(i);
                            objData += `vt ${u.toFixed(6)} ${v.toFixed(6)}\n`;
                        }
                    }
                    
                    // Write normals if available
                    if (normal) {
                        objData += `\n# Normals\n`;
                        for (let i = 0; i < normal.count; i++) {
                            const nx = normal.getX(i);
                            const ny = normal.getY(i);
                            const nz = normal.getZ(i);
                            objData += `vn ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n`;
                        }
                    }
                    
                    // Write faces
                    objData += `\n# Faces\n`;
                    if (index) {
                        // Indexed geometry
                        for (let i = 0; i < index.count; i += 3) {
                            const a = index.getX(i) + totalVertices + 1;     // OBJ is 1-indexed
                            const b = index.getX(i + 1) + totalVertices + 1;
                            const c = index.getX(i + 2) + totalVertices + 1;
                            
                            if (uv && normal) {
                                objData += `f ${a}/${a}/${a} ${b}/${b}/${b} ${c}/${c}/${c}\n`;
                            } else if (uv) {
                                objData += `f ${a}/${a} ${b}/${b} ${c}/${c}\n`;
                            } else if (normal) {
                                objData += `f ${a}//${a} ${b}//${b} ${c}//${c}\n`;
                            } else {
                                objData += `f ${a} ${b} ${c}\n`;
                            }
                        }
                    } else {
                        // Non-indexed geometry
                        for (let i = 0; i < position.count; i += 3) {
                            const a = i + totalVertices + 1;
                            const b = i + 1 + totalVertices + 1;
                            const c = i + 2 + totalVertices + 1;
                            
                            if (uv && normal) {
                                objData += `f ${a}/${a}/${a} ${b}/${b}/${b} ${c}/${c}/${c}\n`;
                            } else if (uv) {
                                objData += `f ${a}/${a} ${b}/${b} ${c}/${c}\n`;
                            } else if (normal) {
                                objData += `f ${a}//${a} ${b}//${b} ${c}//${c}\n`;
                            } else {
                                objData += `f ${a} ${b} ${c}\n`;
                            }
                        }
                    }
                    
                    totalVertices += position.count;
                }
            });
            
            objData += `\n# Export complete. Total vertices: ${totalVertices}\n`;
            return objData;
        };
        
        // Model loading helper function for testing and programmatic access
        const loadModel = async (file, parserType = 'auto') => {
            try {
                const monitor = window.performanceMonitor?.start('Model Loading');
                
                // Auto-detect parser type if not specified
                if (parserType === 'auto') {
                    const ext = file.name.toLowerCase().split('.').pop();
                    if (ext === 'moa') parserType = 'moa';
                    else if (ext === 'prop') parserType = 'prop';
                    else if (ext === 'abc') parserType = 'abc';
                    else parserType = 'moa'; // Default
                }
                
                // Use appropriate parser
                let parsedData;
                switch (parserType) {
                    case 'moa':
                        parsedData = await LithtechParsers.parseMOA(file);
                        break;
                    case 'prop':
                        parsedData = await LithtechParsers.parsePROP(file);
                        break;
                    case 'abc':
                        parsedData = await LithtechParsers.parseABC(file);
                        break;
                    default:
                        throw new Error(`Unsupported parser type: ${parserType}`);
                }
                
                monitor?.end();
                console.log('Model loaded successfully:', parsedData);
                return parsedData;
                
            } catch (error) {
                console.error('Model loading failed:', error);
                throw error;
            }
        };
        
        // Make loadModel globally available for testing
        window.loadModel = loadModel;
        
        // File parsers for Lithtech engine formats
        const LithtechParsers = {
            // Helper function to read string from buffer
            readString: (dataView, offset, length) => {
                let str = '';
                for (let i = 0; i < length; i++) {
                    const char = dataView.getUint8(offset + i);
                    if (char === 0) break; // Null terminator
                    str += String.fromCharCode(char);
                }
                return str;
            },
            
            // Helper to detect file format by magic numbers
            detectFormat: (buffer) => {
                const dataView = new DataView(buffer);
                const magic = dataView.getUint32(0, true);
                const magic2 = dataView.getUint32(4, true);
                
                // Check common MXO magic numbers
                if (magic === 0x504F5250) return 'PROP'; // 'PROP' in hex
                if (magic === 0x414F4D) return 'MOA'; // 'MOA' partial
                if (magic === 0x4D434241) return 'ABCM'; // 'ABCM'
                
                // Check string signatures
                const str = LithtechParsers.readString(dataView, 0, 8);
                if (str.includes('PROP')) return 'PROP';
                if (str.includes('MOA')) return 'MOA';
                if (str.includes('MGA')) return 'MGA';
                if (str.includes('MGC')) return 'MGC';
                
                // Default detection based on patterns
                return 'UNKNOWN';
            },
            // ABC Model Parser (simplified)
            parseABC: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            // Check for ABC header (simplified)
                            const header = new Uint8Array(buffer, 0, 4);
                            const headerStr = String.fromCharCode(...header);
                            
                            if (headerStr !== 'ABCM') {
                                console.warn('Not a valid ABC file, missing ABCM header');
                            }
                            
                            // In a real implementation, this would parse the binary format
                            // For now, we'll return a placeholder object
                            resolve({
                                type: 'model',
                                vertices: [],
                                indices: [],
                                uvs: [],
                                normals: [],
                                animations: [],
                                materials: [],
                                metadata: {
                                    format: 'ABC',
                                    version: 1.0
                                }
                            });
                        } catch (error) {
                            console.error('Error parsing ABC file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            // MGA/MGC Model Group Parser (Matrix Online Model Collections)
            parseMGA: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            const dataView = new DataView(buffer);
                            
                            console.log(`Parsing MXO model group/collection file: ${file.name} (${buffer.byteLength} bytes)`);
                            
                            // Model groups are collections of references to other models
                            // Return placeholder data for now
                            resolve({
                                type: 'model',
                                vertices: [],
                                indices: [],
                                uvs: [],
                                normals: [],
                                metadata: {
                                    format: file.name.endsWith('.mga') ? 'MGA' : 'MGC',
                                    fileType: 'Model Group/Collection',
                                    description: 'Collection of model references'
                                }
                            });
                        } catch (error) {
                            console.error('Error parsing MGA/MGC file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            // PROP Parser - Static props (successfully exported by community)
            parsePROP: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            const dataView = new DataView(buffer);
                            
                            console.log('Parsing PROP file:', file.name);
                            
                            // PROP files are simpler - single mesh
                            // Based on community: successfully exported to .ply/.fbx
                            const vertices = [];
                            const indices = [];
                            const uvs = [];
                            const normals = [];
                            
                            // Try to find vertex data
                            // PROP files typically have vertex count early in file
                            let offset = 0;
                            let vertexCount = 0;
                            let faceCount = 0;
                            
                            // Scan for reasonable vertex/face counts
                            for (let i = 8; i < Math.min(256, buffer.byteLength - 8); i += 4) {
                                const val1 = dataView.getUint32(i, true);
                                const val2 = dataView.getUint32(i + 4, true);
                                
                                if (val1 > 3 && val1 < 65535 && val2 > 1 && val2 < 65535) {
                                    // Possible vertex/face count pair
                                    const testSize = i + 8 + (val1 * 12) + (val2 * 12);
                                    if (testSize < buffer.byteLength) {
                                        vertexCount = val1;
                                        faceCount = val2;
                                        offset = i + 8;
                                        console.log(`Found potential counts at 0x${i.toString(16)}: verts=${vertexCount}, faces=${faceCount}`);
                                        break;
                                    }
                                }
                            }
                            
                            if (vertexCount > 0) {
                                // Read vertices
                                for (let i = 0; i < vertexCount && offset + 12 <= buffer.byteLength; i++) {
                                    const x = dataView.getFloat32(offset, true);
                                    const y = dataView.getFloat32(offset + 4, true);
                                    const z = dataView.getFloat32(offset + 8, true);
                                    
                                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                                        // Apply MXO scale (1 unit = 1cm)
                                        vertices.push(x * 0.01, y * 0.01, z * 0.01);
                                    }
                                    offset += 12;
                                }
                                
                                // Read face indices
                                for (let i = 0; i < faceCount && offset + 12 <= buffer.byteLength; i++) {
                                    const a = dataView.getUint32(offset, true);
                                    const b = dataView.getUint32(offset + 4, true);
                                    const c = dataView.getUint32(offset + 8, true);
                                    
                                    if (a < vertexCount && b < vertexCount && c < vertexCount) {
                                        indices.push(a, b, c);
                                    }
                                    offset += 12;
                                }
                                
                                // Try to read UVs if space remains
                                if (offset + vertexCount * 8 <= buffer.byteLength) {
                                    for (let i = 0; i < vertexCount; i++) {
                                        const u = dataView.getFloat32(offset, true);
                                        const v = dataView.getFloat32(offset + 4, true);
                                        if (!isNaN(u) && !isNaN(v)) {
                                            uvs.push(u, v);
                                        }
                                        offset += 8;
                                    }
                                }
                            }
                            
                            resolve({
                                type: 'model',
                                vertices: vertices,
                                indices: indices,
                                uvs: uvs,
                                normals: normals,
                                animations: [],
                                materials: [],
                                metadata: {
                                    format: 'PROP',
                                    description: 'Static prop/object',
                                    vertexCount: vertices.length / 3,
                                    faceCount: indices.length / 3,
                                    hasUVs: uvs.length > 0,
                                    engine: 'Modified Lithtech Discovery',
                                    scale: '1 unit = 1cm (converted to meters)',
                                    exportable: true, // Community successfully exported these
                                    fileSize: buffer.byteLength
                                }
                            });
                        } catch (error) {
                            console.error('Error parsing PROP file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            // MOA Model Parser - Complex models (characters, vehicles)
            parseMOA: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            const dataView = new DataView(buffer);
                            
                            console.log(`Parsing MXO model file: ${file.name} (${buffer.byteLength} bytes)`);
                            
                            // Generate a thumbnail for the model
                            const createThumbnail = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = 128;
                                canvas.height = 128;
                                const ctx = canvas.getContext('2d');
                                
                                // Background
                                ctx.fillStyle = '#001a00';
                                ctx.fillRect(0, 0, 128, 128);
                                
                                // Simple model representation
                                ctx.strokeStyle = '#00ff00';
                                ctx.lineWidth = 2;
                                
                                // Draw a wireframe model
                                ctx.beginPath();
                                ctx.moveTo(64, 30);  // Top
                                ctx.lineTo(30, 98);  // Bottom left
                                ctx.lineTo(98, 98);  // Bottom right
                                ctx.closePath();
                                ctx.stroke();
                                
                                // Add a caption
                                ctx.fillStyle = '#00ff00';
                                ctx.font = '10px monospace';
                                ctx.fillText(file.name, 5, 120);
                                
                                return canvas.toDataURL('image/png');
                            };
                            
                            // Enhanced MXO model format parsing - Based on Lithtech Discovery engine
                            // Scale: 1 unit = 1 centimeter
                            const analyzeHeader = () => {
                                const header = new Uint8Array(buffer, 0, Math.min(256, buffer.byteLength));
                                const headerBytes = Array.from(header.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                                console.log('MXO model file header bytes:', headerBytes);
                                
                                // Check for common Lithtech signatures
                                const signatures = [
                                    { name: 'MOA', bytes: [0x4D, 0x4F, 0x41] },      // MOA files (character models)
                                    { name: 'PROP', bytes: [0x50, 0x52, 0x4F, 0x50] }, // PROP files (static objects)
                                    { name: 'IPRF', bytes: [0x49, 0x50, 0x52, 0x46] }, // IPRF specialized data
                                    { name: 'EPRF', bytes: [0x45, 0x50, 0x52, 0x46] }, // EPRF specialized data
                                    { name: 'MGA', bytes: [0x4D, 0x47, 0x41] },        // MGA model group
                                    { name: 'MGC', bytes: [0x4D, 0x47, 0x43] },        // MGC model collection
                                    { name: 'LTMP', bytes: [0x4C, 0x54, 0x4D, 0x50] }, // LithTech Model Pack
                                    { name: 'LTB', bytes: [0x4C, 0x54, 0x42] },        // LithTech Binary
                                    { name: 'ABC', bytes: [0x41, 0x42, 0x43] }         // Actor Binary Cache
                                ];
                                
                                for (const sig of signatures) {
                                    let match = true;
                                    for (let i = 0; i < sig.bytes.length; i++) {
                                        if (header[i] !== sig.bytes[i]) {
                                            match = false;
                                            break;
                                        }
                                    }
                                    if (match) {
                                        console.log(`Found ${sig.name} signature at start of file`);
                                        return { signature: sig.name, headerSize: 16 };
                                    }
                                }
                                
                                return { signature: null, headerSize: 0 };
                            };
                            
                            const headerInfo = analyzeHeader();
                            let offset = headerInfo.headerSize;
                            
                            // Try to read header information following instructions.txt structure
                            const parseStructuredData = () => {
                                try {
                                    // Assume 16-byte header as per instructions
                                    let currentOffset = Math.max(16, offset);
                                    
                                    // Try to read vertex and face counts (following instructions.txt example)
                                    if (currentOffset + 8 <= buffer.byteLength) {
                                        const numVertices = dataView.getUint32(currentOffset, true);
                                        const numFaces = dataView.getUint32(currentOffset + 4, true);
                                        currentOffset += 8;
                                        
                                        console.log(`Header parsing: vertices=${numVertices}, faces=${numFaces}`);
                                        
                                        // Validate counts are reasonable
                                        if (numVertices > 0 && numVertices < 100000 && numFaces > 0 && numFaces < 200000) {
                                            const vertices = [];
                                            const faces = [];
                                            const normals = [];
                                            const uvs = [];
                                            
                                            // Read vertices (3 floats: x, y, z) as per instructions.txt
                                            for (let i = 0; i < numVertices && currentOffset + 12 <= buffer.byteLength; i++) {
                                                const x = dataView.getFloat32(currentOffset, true);
                                                const y = dataView.getFloat32(currentOffset + 4, true);
                                                const z = dataView.getFloat32(currentOffset + 8, true);
                                                
                                                // Validate vertex data
                                                if (!isNaN(x) && !isNaN(y) && !isNaN(z) && 
                                                    Math.abs(x) < 10000 && Math.abs(y) < 10000 && Math.abs(z) < 10000) {
                                                    // Apply MXO scale: 1 unit = 1cm, convert to meters for Three.js
                                                    vertices.push(x * 0.01, y * 0.01, z * 0.01);
                                                }
                                                currentOffset += 12;
                                            }
                                            
                                            // Read faces (3 integers: vertex indices) as per instructions.txt
                                            for (let i = 0; i < numFaces && currentOffset + 12 <= buffer.byteLength; i++) {
                                                const a = dataView.getUint32(currentOffset, true);
                                                const b = dataView.getUint32(currentOffset + 4, true);
                                                const c = dataView.getUint32(currentOffset + 8, true);
                                                
                                                // Validate indices
                                                if (a < numVertices && b < numVertices && c < numVertices) {
                                                    faces.push(a, b, c);
                                                }
                                                currentOffset += 12;
                                            }
                                            
                                            // Try to read additional data (normals, UVs)
                                            if (currentOffset + numVertices * 12 <= buffer.byteLength) {
                                                // Read normals
                                                for (let i = 0; i < numVertices; i++) {
                                                    const nx = dataView.getFloat32(currentOffset, true);
                                                    const ny = dataView.getFloat32(currentOffset + 4, true);
                                                    const nz = dataView.getFloat32(currentOffset + 8, true);
                                                    
                                                    if (!isNaN(nx) && !isNaN(ny) && !isNaN(nz)) {
                                                        normals.push(nx, ny, nz);
                                                    }
                                                    currentOffset += 12;
                                                }
                                            }
                                            
                                            if (currentOffset + numVertices * 8 <= buffer.byteLength) {
                                                // Read UVs
                                                for (let i = 0; i < numVertices; i++) {
                                                    const u = dataView.getFloat32(currentOffset, true);
                                                    const v = dataView.getFloat32(currentOffset + 4, true);
                                                    
                                                    if (!isNaN(u) && !isNaN(v)) {
                                                        uvs.push(u, v);
                                                    }
                                                    currentOffset += 8;
                                                }
                                            }
                                            
                                            console.log(`Structured parsing successful: ${vertices.length/3} vertices, ${faces.length/3} faces`);
                                            
                                            return {
                                                vertices,
                                                indices: faces,
                                                normals: normals.length > 0 ? normals : undefined,
                                                uvs: uvs.length > 0 ? uvs : undefined,
                                                success: true
                                            };
                                        }
                                    }
                                } catch (error) {
                                    console.log('Structured parsing failed:', error.message);
                                }
                                
                                return { success: false };
                            };
                            
                            // Try structured parsing first
                            let result = parseStructuredData();
                            
                            // If structured parsing failed, try MXO-specific patterns
                            if (!result.success && (file.name.toLowerCase().endsWith('.moa') || file.name.toLowerCase().endsWith('.prop'))) {
                                console.log('Attempting MXO-specific parsing patterns...');
                                
                                // MXO files often have data at specific offsets
                                // Try common offsets for Lithtech Discovery engine
                                const tryOffsets = [0x40, 0x80, 0x100, 0x200, 0x400];
                                
                                for (const testOffset of tryOffsets) {
                                    if (testOffset + 8 <= buffer.byteLength) {
                                        const possibleVertCount = dataView.getUint32(testOffset, true);
                                        const possibleFaceCount = dataView.getUint32(testOffset + 4, true);
                                        
                                        // Check if these are reasonable values
                                        if (possibleVertCount > 3 && possibleVertCount < 50000 && 
                                            possibleFaceCount > 1 && possibleFaceCount < 100000) {
                                            
                                            console.log(`Found potential counts at offset 0x${testOffset.toString(16)}: verts=${possibleVertCount}, faces=${possibleFaceCount}`);
                                            
                                            // Try to parse from this offset
                                            const vertices = [];
                                            const faces = [];
                                            let currentOffset = testOffset + 8;
                                            
                                            // Try to read vertices
                                            for (let i = 0; i < possibleVertCount && currentOffset + 12 <= buffer.byteLength; i++) {
                                                const x = dataView.getFloat32(currentOffset, true);
                                                const y = dataView.getFloat32(currentOffset + 4, true);
                                                const z = dataView.getFloat32(currentOffset + 8, true);
                                                
                                                if (!isNaN(x) && !isNaN(y) && !isNaN(z) && 
                                                    Math.abs(x) < 10000 && Math.abs(y) < 10000 && Math.abs(z) < 10000) {
                                                    // Apply MXO scale: 1 unit = 1cm, convert to meters for Three.js
                                                    vertices.push(x * 0.01, y * 0.01, z * 0.01);
                                                    currentOffset += 12;
                                                } else {
                                                    break;
                                                }
                                            }
                                            
                                            // If we got enough vertices, try reading faces
                                            if (vertices.length / 3 >= possibleVertCount * 0.8) { // Allow some tolerance
                                                for (let i = 0; i < possibleFaceCount && currentOffset + 12 <= buffer.byteLength; i++) {
                                                    const a = dataView.getUint32(currentOffset, true);
                                                    const b = dataView.getUint32(currentOffset + 4, true);
                                                    const c = dataView.getUint32(currentOffset + 8, true);
                                                    
                                                    if (a < possibleVertCount && b < possibleVertCount && c < possibleVertCount) {
                                                        faces.push(a, b, c);
                                                        currentOffset += 12;
                                                    } else {
                                                        break;
                                                    }
                                                }
                                                
                                                if (faces.length / 3 >= possibleFaceCount * 0.5) { // Some tolerance for faces
                                                    result = {
                                                        vertices,
                                                        indices: faces,
                                                        success: true
                                                    };
                                                    console.log(`MXO parsing successful at offset 0x${testOffset.toString(16)}`);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // If structured parsing failed, try pattern-based approach
                            if (!result.success) {
                                console.log('Attempting pattern-based parsing...');
                                
                                const vertices = [];
                                const indices = [];
                                
                                // Scan for vertex data patterns
                                for (let i = 32; i < buffer.byteLength - 12; i += 4) {
                                    const x = dataView.getFloat32(i, true);
                                    const y = dataView.getFloat32(i + 4, true);
                                    const z = dataView.getFloat32(i + 8, true);
                                    
                                    // Look for reasonable vertex coordinates
                                    if (!isNaN(x) && !isNaN(y) && !isNaN(z) && 
                                        Math.abs(x) < 1000 && Math.abs(y) < 1000 && Math.abs(z) < 1000 &&
                                        (Math.abs(x) > 0.001 || Math.abs(y) > 0.001 || Math.abs(z) > 0.001)) {
                                        // Apply MXO scale: 1 unit = 1cm, convert to meters for Three.js
                                        vertices.push(x * 0.01, y * 0.01, z * 0.01);
                                        
                                        // Limit vertices to prevent performance issues
                                        if (vertices.length >= 3000) break;
                                    }
                                }
                                
                                // Generate triangulated indices if we found vertices
                                if (vertices.length >= 9) { // At least 3 vertices
                                    const numVerts = vertices.length / 3;
                                    for (let i = 0; i < numVerts - 2; i += 3) {
                                        if (i + 2 < numVerts) {
                                            indices.push(i, i + 1, i + 2);
                                        }
                                    }
                                }
                                
                                result = {
                                    vertices,
                                    indices,
                                    normals: undefined,
                                    uvs: undefined,
                                    success: vertices.length > 0
                                };
                                
                                console.log(`Pattern-based parsing: ${vertices.length/3} vertices found`);
                            }
                            
                            // Create final result
                            if (result.success && result.vertices.length > 0) {
                                resolve({
                                    type: 'model',
                                    vertices: result.vertices,
                                    indices: result.indices,
                                    normals: result.normals,
                                    uvs: result.uvs,
                                    animations: [],
                                    materials: [],
                                    thumbnail: createThumbnail(),
                                    metadata: {
                                        format: file.name.toLowerCase().endsWith('.moa') ? 'MOA' : 
                                               file.name.toLowerCase().endsWith('.prop') ? 'PROP' : 
                                               file.name.toLowerCase().endsWith('.iprf') ? 'IPRF' : 
                                               file.name.toLowerCase().endsWith('.eprf') ? 'EPRF' : 
                                               file.name.toLowerCase().endsWith('.mga') ? 'MGA' : 
                                               file.name.toLowerCase().endsWith('.mgc') ? 'MGC' : 'MXO',
                                        version: 1.0,
                                        signature: headerInfo.signature,
                                        vertexCount: result.vertices.length / 3,
                                        triangleCount: result.indices.length / 3,
                                        description: file.name.toLowerCase().endsWith('.moa') ? 'Character model/clothing/vehicle' : 
                                                    file.name.toLowerCase().endsWith('.prop') ? 'Static prop/object' : 
                                                    file.name.toLowerCase().endsWith('.mga') || file.name.toLowerCase().endsWith('.mgc') ? 'Model group/collection' :
                                                    file.name.toLowerCase().endsWith('.iprf') || file.name.toLowerCase().endsWith('.eprf') ? 'Specialized model data' :
                                                    'Matrix Online model',
                                        parsedBy: 'Enhanced MXO parser v3.0',
                                        fileSize: buffer.byteLength,
                                        hasNormals: !!result.normals,
                                        hasUVs: !!result.uvs,
                                        engine: 'Modified Lithtech Discovery',
                                        scale: '1 unit = 1 centimeter (converted to meters)',
                                        originalScale: 'MXO: 1 unit = 1cm',
                                        scaleFactor: 0.01
                                    }
                                });
                            } else {
                                // Create a fallback simple model (already in meters)
                                const fallbackVertices = [
                                    -1, -1, 0,   // Bottom left
                                     1, -1, 0,   // Bottom right
                                     0,  1, 0,   // Top
                                    -0.5, 0, 1,  // Back left
                                     0.5, 0, 1   // Back right
                                ];
                                
                                const fallbackIndices = [
                                    0, 1, 2,  // Front triangle
                                    0, 3, 4,  // Back left triangle
                                    1, 4, 2,  // Back right triangle
                                    3, 4, 2   // Back top triangle
                                ];
                                
                                console.log('Using fallback model for MOB file');
                                
                                resolve({
                                    type: 'model',
                                    vertices: fallbackVertices,
                                    indices: fallbackIndices,
                                    normals: undefined,
                                    uvs: undefined,
                                    animations: [],
                                    materials: [],
                                    thumbnail: createThumbnail(),
                                    metadata: {
                                        format: file.name.toLowerCase().endsWith('.moa') ? 'MOA' : 
                                               file.name.toLowerCase().endsWith('.prop') ? 'PROP' : 
                                               file.name.toLowerCase().endsWith('.iprf') ? 'IPRF' : 
                                               file.name.toLowerCase().endsWith('.eprf') ? 'EPRF' : 
                                               file.name.toLowerCase().endsWith('.mga') ? 'MGA' : 
                                               file.name.toLowerCase().endsWith('.mgc') ? 'MGC' : 'MXO',
                                        version: 1.0,
                                        signature: headerInfo.signature,
                                        vertexCount: 5,
                                        triangleCount: 4,
                                        description: file.name.toLowerCase().endsWith('.moa') ? 'Character model (placeholder)' : 
                                                    file.name.toLowerCase().endsWith('.prop') ? 'Static prop (placeholder)' : 
                                                    file.name.toLowerCase().endsWith('.mga') || file.name.toLowerCase().endsWith('.mgc') ? 'Model group (placeholder)' :
                                                    file.name.toLowerCase().endsWith('.iprf') || file.name.toLowerCase().endsWith('.eprf') ? 'Specialized model (placeholder)' :
                                                    'Matrix Online model (placeholder)',
                                        parsedBy: 'Enhanced MXO parser v3.0 (fallback)',
                                        fileSize: buffer.byteLength,
                                        warning: 'Could not parse actual model data, using placeholder',
                                        engine: 'Modified Lithtech Discovery',
                                        scale: '1 unit = 1 centimeter'
                                    }
                                });
                            }
                        } catch (error) {
                            console.error('Error parsing MXO model file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            // Cutscene/Video Parser
            parseCutscene: async (file) => {
                return new Promise(async (resolve, reject) => {
                    try {
                        let videoUrl;
                        
                        // Check if this is a BIK file that needs conversion
                        if (file.name.toLowerCase().endsWith('.bik')) {
                            // Use the BIK proxy server to get a streamable URL
                            try {
                                const response = await fetch('http://localhost:8002/proxy-url', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    body: JSON.stringify({
                                        path: file.webkitRelativePath || file.path || file.name
                                    })
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    videoUrl = data.url;
                                    console.log('BIK proxy URL:', videoUrl);
                                } else {
                                    console.error('BIK proxy server error:', response.status);
                                    // Fallback to blob URL (won't play but won't crash)
                                    videoUrl = URL.createObjectURL(file);
                                }
                            } catch (error) {
                                console.error('Failed to get BIK proxy URL:', error);
                                // Fallback to blob URL
                                videoUrl = URL.createObjectURL(file);
                            }
                        } else {
                            // For other video formats, create a regular blob URL
                            videoUrl = URL.createObjectURL(file);
                        }
                        
                        // Create a video element to extract metadata and thumbnail
                        const video = document.createElement('video');
                        video.src = videoUrl;
                        
                        // Set up event listeners
                        video.onloadedmetadata = () => {
                            // Get video metadata
                            const duration = video.duration;
                            const width = video.videoWidth;
                            const height = video.videoHeight;
                            
                            // Create a thumbnail from the video
                            const createThumbnail = () => {
                                // Seek to 25% of the video for thumbnail
                                video.currentTime = duration * 0.25;
                                
                                video.onseeked = () => {
                                    // Create canvas for thumbnail
                                    const canvas = document.createElement('canvas');
                                    canvas.width = 128;
                                    canvas.height = 128;
                                    const ctx = canvas.getContext('2d');
                                    
                                    // Calculate aspect ratio
                                    const aspectRatio = width / height;
                                    let thumbWidth, thumbHeight, offsetX = 0, offsetY = 0;
                                    
                                    if (aspectRatio > 1) {
                                        // Wider than tall
                                        thumbWidth = 128;
                                        thumbHeight = 128 / aspectRatio;
                                        offsetY = (128 - thumbHeight) / 2;
                                    } else {
                                        // Taller than wide or square
                                        thumbHeight = 128;
                                        thumbWidth = 128 * aspectRatio;
                                        offsetX = (128 - thumbWidth) / 2;
                                    }
                                    
                                    // Matrix-style background
                                    ctx.fillStyle = '#001a00';
                                    ctx.fillRect(0, 0, 128, 128);
                                    
                                    // Draw the video frame
                                    ctx.drawImage(video, offsetX, offsetY, thumbWidth, thumbHeight);
                                    
                                    // Add a play button overlay
                                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                                    ctx.beginPath();
                                    ctx.arc(64, 64, 25, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Draw play triangle
                                    ctx.fillStyle = '#00ff00';
                                    ctx.beginPath();
                                    ctx.moveTo(58, 50);
                                    ctx.lineTo(78, 64);
                                    ctx.lineTo(58, 78);
                                    ctx.closePath();
                                    ctx.fill();
                                    
                                    // Add border
                                    ctx.strokeStyle = '#00ff00';
                                    ctx.lineWidth = 2;
                                    ctx.strokeRect(offsetX, offsetY, thumbWidth, thumbHeight);
                                    
                                    // Add filename
                                    ctx.fillStyle = '#00ff00';
                                    ctx.font = '9px monospace';
                                    const shortName = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
                                    ctx.fillText(shortName, 5, 125);
                                    
                                    // Format duration
                                    const minutes = Math.floor(duration / 60);
                                    const seconds = Math.floor(duration % 60);
                                    const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                                    ctx.fillText(durationStr, 100, 125);
                                    
                                    // Return the thumbnail as data URL
                                    const thumbnailDataUrl = canvas.toDataURL('image/png');
                                    
                                    // Release the video object URL
                                    video.pause();
                                    
                                    // Resolve with video info
                                    resolve({
                                        type: 'cutscene',
                                        src: videoUrl,
                                        url: videoUrl,  // Add url property for CutscenePlayer
                                        width: width,
                                        height: height,
                                        duration: duration,
                                        thumbnail: thumbnailDataUrl,
                                        format: file.name.split('.').pop().toUpperCase(),
                                        metadata: {
                                            duration: duration,
                                            width: width,
                                            height: height,
                                            aspectRatio: aspectRatio,
                                            format: file.name.split('.').pop().toUpperCase(),
                                            fileSize: file.size,
                                            isBik: file.name.toLowerCase().endsWith('.bik')
                                        }
                                    });
                                };
                            };
                            
                            // If this is a BIK file, start with error handler setup
                            if (file.name.toLowerCase().endsWith('.bik')) {
                                // For BIK files, create thumbnail without loading video
                                const createBikThumbnail = () => {
                                    const canvas = document.createElement('canvas');
                                    canvas.width = 128;
                                    canvas.height = 128;
                                    const ctx = canvas.getContext('2d');
                                    
                                    // Matrix-style background
                                    ctx.fillStyle = '#001a00';
                                    ctx.fillRect(0, 0, 128, 128);
                                    
                                    // Add BIK icon
                                    ctx.fillStyle = '#00ff00';
                                    ctx.font = 'bold 24px monospace';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('BIK', 64, 60);
                                    
                                    // Add play button
                                    ctx.strokeStyle = '#00ff00';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.arc(64, 64, 25, 0, Math.PI * 2);
                                    ctx.stroke();
                                    
                                    // Draw play triangle
                                    ctx.fillStyle = '#00ff00';
                                    ctx.beginPath();
                                    ctx.moveTo(58, 50);
                                    ctx.lineTo(78, 64);
                                    ctx.lineTo(58, 78);
                                    ctx.closePath();
                                    ctx.fill();
                                    
                                    // Add filename
                                    ctx.fillStyle = '#00ff00';
                                    ctx.font = '9px monospace';
                                    ctx.textAlign = 'left';
                                    const shortName = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
                                    ctx.fillText(shortName, 5, 125);
                                    
                                    return canvas.toDataURL('image/png');
                                };
                                
                                // Resolve immediately with BIK info
                                resolve({
                                    type: 'cutscene',
                                    src: videoUrl,
                                    url: videoUrl,
                                    width: 640,
                                    height: 480,
                                    duration: 0,
                                    thumbnail: createBikThumbnail(),
                                    format: 'BIK',
                                    metadata: {
                                        duration: 0,
                                        width: 640,
                                        height: 480,
                                        aspectRatio: 640/480,
                                        format: 'BIK',
                                        fileSize: file.size,
                                        isBik: true,
                                        note: 'BIK video will be converted on playback'
                                    }
                                });
                                return;
                            }
                            
                            // Handle case where seeking doesn't work
                            video.onerror = () => {
                                // Create a fallback thumbnail
                                const canvas = document.createElement('canvas');
                                canvas.width = 128;
                                canvas.height = 128;
                                const ctx = canvas.getContext('2d');
                                
                                // Matrix-style background
                                ctx.fillStyle = '#001a00';
                                ctx.fillRect(0, 0, 128, 128);
                                
                                // Add a play button
                                ctx.fillStyle = 'rgba(0, 30, 0, 0.7)';
                                ctx.beginPath();
                                ctx.arc(64, 64, 30, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Draw play triangle
                                ctx.fillStyle = '#00ff00';
                                ctx.beginPath();
                                ctx.moveTo(55, 45);
                                ctx.lineTo(85, 64);
                                ctx.lineTo(55, 83);
                                ctx.closePath();
                                ctx.fill();
                                
                                // Add border
                                ctx.strokeStyle = '#00ff00';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(4, 4, 120, 120);
                                
                                // Add video info
                                ctx.fillStyle = '#00ff00';
                                ctx.font = '10px monospace';
                                ctx.fillText('Video: ' + file.name, 10, 20);
                                
                                if (duration) {
                                    const minutes = Math.floor(duration / 60);
                                    const seconds = Math.floor(duration % 60);
                                    ctx.fillText(`Duration: ${minutes}:${seconds.toString().padStart(2, '0')}`, 10, 36);
                                }
                                
                                if (width && height) {
                                    ctx.fillText(`Resolution: ${width}x${height}`, 10, 52);
                                }
                                
                                // Resolve with video info and fallback thumbnail
                                resolve({
                                    type: 'cutscene',
                                    src: videoUrl,
                                    width: width || 640,
                                    height: height || 480,
                                    duration: duration || 0,
                                    thumbnail: canvas.toDataURL('image/png'),
                                    format: file.name.split('.').pop().toUpperCase(),
                                    metadata: {
                                        duration: duration || 0,
                                        width: width || 640,
                                        height: height || 480,
                                        aspectRatio: width && height ? width / height : 1.33,
                                        format: file.name.split('.').pop().toUpperCase(),
                                        fileSize: file.size
                                    }
                                });
                            };
                            
                            // Try to create the thumbnail
                            createThumbnail();
                        };
                        
                        // Handle loading errors
                        video.onerror = () => {
                            console.error('Error loading video:', file.name);
                            
                            // Create a fallback thumbnail for error case
                            const canvas = document.createElement('canvas');
                            canvas.width = 128;
                            canvas.height = 128;
                            const ctx = canvas.getContext('2d');
                            
                            // Matrix-style background
                            ctx.fillStyle = '#001a00';
                            ctx.fillRect(0, 0, 128, 128);
                            
                            // Error indicator
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(64, 64, 30, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // X mark
                            ctx.strokeStyle = '#001a00';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.moveTo(50, 50);
                            ctx.lineTo(78, 78);
                            ctx.moveTo(78, 50);
                            ctx.lineTo(50, 78);
                            ctx.stroke();
                            
                            // Add border
                            ctx.strokeStyle = '#00ff00';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(4, 4, 120, 120);
                            
                            // Add error info
                            ctx.fillStyle = '#00ff00';
                            ctx.font = '10px monospace';
                            ctx.fillText('Error loading:', 10, 20);
                            
                            // Filename (split into multiple lines if needed)
                            const maxLength = 16;
                            if (file.name.length > maxLength) {
                                ctx.fillText(file.name.substring(0, maxLength), 10, 36);
                                ctx.fillText(file.name.substring(maxLength), 10, 52);
                            } else {
                                ctx.fillText(file.name, 10, 36);
                            }
                            
                            // Resolve with error info and fallback thumbnail
                            resolve({
                                type: 'cutscene',
                                src: videoUrl,
                                error: true,
                                thumbnail: canvas.toDataURL('image/png'),
                                format: file.name.split('.').pop().toUpperCase(),
                                metadata: {
                                    error: 'Failed to load video',
                                    format: file.name.split('.').pop().toUpperCase(),
                                    fileSize: file.size
                                }
                            });
                        };
                        
                        // Load the video to trigger the metadata loading
                        video.load();
                    } catch (error) {
                        console.error('Error parsing video file:', error);
                        reject(error);
                    }
                });
            },
            
            // Texture Parser - Handles .txa, .txb, .dtx, .dds and standard formats
            parseTexture: async (file) => {
                return new Promise((resolve, reject) => {
                    const fileExt = '.' + file.name.split('.').pop().toLowerCase();
                    
                    // For TXA/TXB files, we need server-side conversion to DDS
                    if (fileExt === '.txa' || fileExt === '.txb') {
                        console.log('TXA/TXB texture detected - needs conversion to DDS');
                        
                        // Create a placeholder with info about conversion requirement
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 256;
                        const ctx = canvas.getContext('2d');
                        
                        // Matrix-style placeholder
                        ctx.fillStyle = '#001a00';
                        ctx.fillRect(0, 0, 256, 256);
                        
                        // Add grid pattern
                        ctx.strokeStyle = '#003300';
                        for (let i = 0; i < 256; i += 32) {
                            ctx.beginPath();
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i, 256);
                            ctx.moveTo(0, i);
                            ctx.lineTo(256, i);
                            ctx.stroke();
                        }
                        
                        ctx.strokeStyle = '#00ff00';
                        ctx.strokeRect(0, 0, 256, 256);
                        ctx.font = '14px monospace';
                        ctx.fillStyle = '#00ff00';
                        ctx.fillText('TXA/TXB Texture', 10, 128);
                        ctx.font = '12px monospace';
                        ctx.fillText('Requires txa2dds', 10, 148);
                        ctx.fillText('conversion', 10, 162);
                        
                        resolve({
                            type: 'texture',
                            canvas: canvas,
                            width: 256,
                            height: 256,
                            format: fileExt.toUpperCase(),
                            metadata: {
                                format: 'Matrix Online Texture',
                                compression: 'DXT (after conversion)',
                                converter: 'txa2dds.exe required',
                                description: 'Proprietary MXO texture format',
                                needsConversion: true
                            }
                        });
                    } else if (fileExt === '.dds') {
                        // For DDS files, we'd need DDSLoader
                        // For now, show placeholder with DDS info
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 256;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.fillStyle = '#001a00';
                        ctx.fillRect(0, 0, 256, 256);
                        ctx.strokeStyle = '#00ff00';
                        ctx.strokeRect(0, 0, 256, 256);
                        ctx.font = '14px monospace';
                        ctx.fillStyle = '#00ff00';
                        ctx.fillText('DDS Texture', 10, 128);
                        ctx.fillText('(DXT Compressed)', 10, 148);
                        
                        resolve({
                            type: 'texture',
                            canvas: canvas,
                            width: 256,
                            height: 256,
                            format: 'DDS',
                            metadata: {
                                format: 'DirectDraw Surface',
                                compression: 'DXT1/DXT5',
                                mipLevels: 'Multiple',
                                description: 'Converted from TXA/TXB'
                            }
                        });
                    } else {
                        // Standard image formats - delegate to DTX parser
                        LithtechParsers.parseDTX(file).then(resolve).catch(reject);
                    }
                });
            },
            
            // DTX Texture Parser (improved)
            parseDTX: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            // Check for DTX header (simplified)
                            const header = new Uint8Array(buffer, 0, 4);
                            
                            // Convert header bytes to string for inspection
                            const headerStr = Array.from(header)
                                .map(byte => String.fromCharCode(byte))
                                .join('');
                            
                            console.log(`DTX header: ${headerStr} [${Array.from(header).map(b => b.toString(16).padStart(2, '0')).join(' ')}]`);
                            
                            // DTX files might not have a consistent header
                            // We'll try to detect common image formats and render those too
                            const tryImageRead = () => {
                                // Let's try to read it as a normal image file
                                const imageReader = new FileReader();
                                imageReader.onload = (imgEvent) => {
                                    const img = new Image();
                                    img.onload = () => {
                                        // Successfully loaded as an image
                                        const canvas = document.createElement('canvas');
                                        canvas.width = img.width;
                                        canvas.height = img.height;
                                        const ctx = canvas.getContext('2d');
                                        ctx.drawImage(img, 0, 0);
                                        
                                        // Create thumbnail
                                        const thumbnailCanvas = document.createElement('canvas');
                                        thumbnailCanvas.width = 128;
                                        thumbnailCanvas.height = 128;
                                        const thumbCtx = thumbnailCanvas.getContext('2d');
                                        
                                        // Maintain aspect ratio for thumbnail
                                        const aspectRatio = img.width / img.height;
                                        let thumbWidth, thumbHeight, offsetX = 0, offsetY = 0;
                                        
                                        if (aspectRatio > 1) {
                                            // Wider than tall
                                            thumbWidth = 128;
                                            thumbHeight = 128 / aspectRatio;
                                            offsetY = (128 - thumbHeight) / 2;
                                        } else {
                                            // Taller than wide or square
                                            thumbHeight = 128;
                                            thumbWidth = 128 * aspectRatio;
                                            offsetX = (128 - thumbWidth) / 2;
                                        }
                                        
                                        // Matrix-style background
                                        thumbCtx.fillStyle = '#001a00';
                                        thumbCtx.fillRect(0, 0, 128, 128);
                                        
                                        // Draw the image maintaining aspect ratio
                                        thumbCtx.drawImage(img, offsetX, offsetY, thumbWidth, thumbHeight);
                                        
                                        // Add border
                                        thumbCtx.strokeStyle = '#00ff00';
                                        thumbCtx.lineWidth = 2;
                                        thumbCtx.strokeRect(offsetX, offsetY, thumbWidth, thumbHeight);
                                        
                                        // Add filename
                                        thumbCtx.fillStyle = '#00ff00';
                                        thumbCtx.font = '9px monospace';
                                        const shortName = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
                                        thumbCtx.fillText(shortName, 5, 125);
                                        
                                        resolve({
                                            type: 'texture',
                                            canvas: canvas,
                                            width: img.width,
                                            height: img.height,
                                            format: 'Image',
                                            rawData: imgEvent.target.result,
                                            thumbnail: thumbnailCanvas.toDataURL('image/png'),
                                            metadata: {
                                                material: 'default',
                                                properties: {
                                                    reflective: false,
                                                    transparent: false
                                                }
                                            }
                                        });
                                    };
                                    
                                    img.onerror = () => {
                                        // Couldn't load as normal image, create placeholder
                                        createPlaceholder();
                                    };
                                    
                                    img.src = imgEvent.target.result;
                                };
                                
                                imageReader.onerror = () => {
                                    // Couldn't read as image, create placeholder
                                    createPlaceholder();
                                };
                                
                                imageReader.readAsDataURL(file);
                            };
                            
                            const createPlaceholder = () => {
                                // Create a placeholder texture with matrix-style pattern
                                const canvas = document.createElement('canvas');
                                canvas.width = 256;
                                canvas.height = 256;
                                const ctx = canvas.getContext('2d');
                                
                                // Matrix-inspired background
                                ctx.fillStyle = '#001a00';
                                ctx.fillRect(0, 0, 256, 256);
                                
                                // Create a matrix-like pattern
                                ctx.font = '14px monospace';
                                ctx.fillStyle = '#00ff00';
                                
                                // Generate random matrix characters
                                for (let y = 10; y < 256; y += 16) {
                                    for (let x = 10; x < 256; x += 16) {
                                        // Random matrix character
                                        const char = String.fromCharCode(Math.floor(Math.random() * 93) + 33);
                                        ctx.fillText(char, x, y);
                                    }
                                }
                                
                                // Label
                                ctx.fillStyle = '#00ff00';
                                ctx.font = '16px monospace';
                                ctx.fillText(`${file.name}`, 20, 128);
                                ctx.fillText(`DTX Texture Viewer`, 20, 148);
                                
                                // Border
                                ctx.strokeStyle = '#00ff00';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(4, 4, 248, 248);
                                
                                // Create thumbnail copy for consistency
                                const thumbnailCanvas = document.createElement('canvas');
                                thumbnailCanvas.width = 128;
                                thumbnailCanvas.height = 128;
                                const thumbCtx = thumbnailCanvas.getContext('2d');
                                
                                // Matrix-style background
                                thumbCtx.fillStyle = '#001a00';
                                thumbCtx.fillRect(0, 0, 128, 128);
                                
                                // Create a matrix-like pattern for thumbnail
                                thumbCtx.font = '8px monospace';
                                thumbCtx.fillStyle = '#00ff00';
                                
                                // Generate random matrix characters
                                for (let y = 8; y < 128; y += 12) {
                                    for (let x = 8; x < 128; x += 10) {
                                        // Random matrix character
                                        const char = String.fromCharCode(Math.floor(Math.random() * 93) + 33);
                                        thumbCtx.fillText(char, x, y);
                                    }
                                }
                                
                                // Label
                                thumbCtx.fillStyle = '#00ff00';
                                thumbCtx.font = '10px monospace';
                                thumbCtx.fillText('DTX Texture', 5, 64);
                                
                                // Filename
                                const shortName = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
                                thumbCtx.fillText(shortName, 5, 120);
                                
                                // Border
                                thumbCtx.strokeStyle = '#00ff00';
                                thumbCtx.lineWidth = 2;
                                thumbCtx.strokeRect(4, 4, 120, 120);
                                
                                resolve({
                                    type: 'texture',
                                    canvas: canvas,
                                    width: 256,
                                    height: 256,
                                    format: 'DTX',
                                    thumbnail: thumbnailCanvas.toDataURL('image/png'),
                                    metadata: {
                                        material: 'default',
                                        properties: {
                                            reflective: false,
                                            transparent: false
                                        }
                                    }
                                });
                            };
                            
                            // If we have a valid DTX header (unlikely in demo), we'd parse it
                            // Otherwise, try as normal image or create placeholder
                            if (headerStr === 'DTX\0') {
                                // Parse DTX format - this is a placeholder
                                createPlaceholder();
                            } else {
                                // Try to read as normal image
                                tryImageRead();
                            }
                        } catch (error) {
                            console.error('Error parsing DTX file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            // DAT Level Parser (simplified)
            parseDAT: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            // In a real implementation, this would parse the level format
                            // using Kaitai Struct or similar
                            resolve({
                                type: 'level',
                                geometry: [],
                                entities: [],
                                navmesh: [],
                                metadata: {
                                    format: 'DAT',
                                    version: 1.0
                                }
                            });
                        } catch (error) {
                            console.error('Error parsing DAT file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            // REZ/LTA/PKB Archive Parser (improved)
            parseArchive: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            const fileExt = '.' + file.name.split('.').pop().toLowerCase();
                            
                            // Determine archive format and parse accordingly
                            let files = [];
                            let format = '';
                            
                            if (fileExt === '.rez') {
                                // Parse REZ format (simplified)
                                format = 'REZ';
                                // REZ files typically have a header followed by a directory
                                const view = new DataView(buffer);
                                const signature = String.fromCharCode(
                                    view.getUint8(0),
                                    view.getUint8(1),
                                    view.getUint8(2),
                                    view.getUint8(3)
                                );
                                
                                if (signature !== 'REZF') {
                                    console.warn('Invalid REZ file signature');
                                }
                                
                                // Simulate parsing the directory - validate buffer sizes to prevent invalid typed array length errors
                                const bufferSize = buffer.byteLength;
                                const safeCreateDataView = (offset, size) => {
                                    // Make sure we don't try to create a view that exceeds the buffer
                                    const safeOffset = Math.min(offset, bufferSize - 1);
                                    const safeSize = Math.min(size, bufferSize - safeOffset);
                                    return new Uint8Array(buffer, safeOffset, safeSize);
                                };
                                
                                files = [
                                    { name: 'textures/character01.dtx', size: 1024, offset: 0, data: safeCreateDataView(0, 1024) },
                                    { name: 'models/character01.abc', size: 1024, offset: 1024, data: safeCreateDataView(1024, 1024) },
                                    { name: 'levels/level01.dat', size: 1024, offset: 2048, data: safeCreateDataView(2048, 1024) },
                                    { name: 'scripts/ai.lua', size: 1024, offset: 3072, data: safeCreateDataView(3072, 1024) }
                                ];
                            } else if (fileExt === '.lta' || fileExt === '.ltb') {
                                // Parse LTA/LTB format (simplified)
                                format = fileExt === '.lta' ? 'LTA' : 'LTB';
                                
                                // Simulate parsing with safe buffer access
                                const bufferSize = buffer.byteLength;
                                const safeCreateDataView = (offset, size) => {
                                    // Make sure we don't try to create a view that exceeds the buffer
                                    const safeOffset = Math.min(offset, bufferSize - 1);
                                    const safeSize = Math.min(size, bufferSize - safeOffset);
                                    return new Uint8Array(buffer, safeOffset, safeSize);
                                };
                                
                                files = [
                                    { name: 'section1.data', size: 1024, offset: 0, data: safeCreateDataView(0, 1024) },
                                    { name: 'section2.data', size: 1024, offset: 1024, data: safeCreateDataView(1024, 1024) },
                                    { name: 'section3.data', size: 1024, offset: 2048, data: safeCreateDataView(2048, 1024) }
                                ];
                            } else if (fileExt === '.pkb') {
                                // Parse PKB format (Matrix Online packed archives)
                                format = 'PKB';
                                const view = new DataView(buffer);
                                
                                console.log(`Processing PKB: ${file.name} (${buffer.byteLength} bytes)`);
                                
                                // Store PKB data globally for extraction
                                if (!window.MXO_PKB_FILES) {
                                    window.MXO_PKB_FILES = {};
                                }
                                window.MXO_PKB_FILES[file.name.toLowerCase()] = buffer;
                                
                                // PKB files in MXO don't have a standard header
                                // They require packmap_save.lta index file for proper extraction
                                // Without it, we can only show info about the PKB
                                
                                // Create an info file explaining the PKB contents
                                const pkbInfo = {
                                    'char_npc.pkb': 'NPC character models (.moa files)',
                                    'zmisc_1.pkb': 'Miscellaneous props and objects',
                                    'worlds_1.pkb': 'World/level geometry data',
                                    'worlds_2c.pkb': 'World/level geometry data',
                                    'worlds_3g.pkb': 'World/level geometry data',
                                    'prefabs_6m4.pkb': 'Prefab objects and structures'
                                };
                                
                                const baseName = file.name.toLowerCase();
                                const description = pkbInfo[baseName] || 'Unknown PKB archive contents';
                                
                                const infoText = [
                                    `PKB Archive: ${file.name}`,
                                    `Size: ${(buffer.byteLength / 1024 / 1024).toFixed(2)} MB`,
                                    `Type: ${description}`,
                                    '',
                                    'This PKB file contains packed Matrix Online assets.',
                                    '',
                                    'To extract files from this archive, you need:',
                                    '1. The index file (packmap_save.lta or rezmap.lta)',
                                    '2. The index contains file names, offsets, and sizes',
                                    '3. Use the index data to extract specific files',
                                    '',
                                    'Known contents:',
                                    '- .moa files (character models, vehicles)',
                                    '- .prop files (static objects)',
                                    '- .txa/.txb files (textures)',
                                    '',
                                    'PKB files are packed for efficiency and anti-tampering.',
                                    'All ~44,000 game objects are compressed into these archives.'
                                ].join('\n');
                                
                                const blob = new Blob([infoText], { type: 'text/plain' });
                                
                                // Since we're in a non-async context, use the text directly
                                const encoder = new TextEncoder();
                                const infoData = encoder.encode(infoText);
                                
                                files = [{
                                    name: `${file.name.replace('.pkb', '')}_info.txt`,
                                    size: infoData.length,
                                    offset: 0,
                                    data: infoData
                                }];
                                
                                console.log('PKB file loaded and stored for extraction');
                            }
                            
                            resolve({
                                type: 'archive',
                                files: files,
                                rawBuffer: buffer,
                                metadata: {
                                    format: format,
                                    version: 1.0,
                                    fileCount: files.length,
                                    totalSize: buffer.byteLength
                                }
                            });
                        } catch (error) {
                            console.error('Error parsing archive file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            // Message Parser (simplified)
            parseMessage: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            // For MSG files, we'll just treat them as text
                            const text = e.target.result;
                            resolve({
                                type: 'message',
                                content: text,
                                metadata: {
                                    format: 'MSG',
                                    version: 1.0
                                }
                            });
                        } catch (error) {
                            console.error('Error parsing MSG file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            },
            
            // Assembly (DLL/EXE) Parser
            parseAssembly: async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const buffer = e.target.result;
                            const view = new DataView(buffer);
                            
                            // Check for PE header (MZ signature)
                            const mzSignature = view.getUint16(0, true);
                            if (mzSignature !== 0x5A4D) { // 'MZ' in little-endian
                                console.warn('Not a valid PE file, missing MZ header');
                                reject(new Error('Invalid PE file format'));
                                return;
                            }
                            
                            // Get PE header offset (at 0x3C)
                            const peOffset = view.getUint32(0x3C, true);
                            
                            // Check for PE signature
                            const peSignature = view.getUint32(peOffset, true);
                            if (peSignature !== 0x4550) { // 'PE\0\0' in little-endian
                                console.warn('Not a valid PE file, missing PE signature');
                                reject(new Error('Invalid PE file format'));
                                return;
                            }
                            
                            // Parse basic PE information
                            const machine = view.getUint16(peOffset + 4, true);
                            const numberOfSections = view.getUint16(peOffset + 6, true);
                            const timeDateStamp = view.getUint32(peOffset + 8, true);
                            const characteristics = view.getUint16(peOffset + 22, true);
                            
                            // Check if it's a DLL
                            const isDll = (characteristics & 0x2000) !== 0;
                            
                            // Parse sections (simplified)
                            const sections = [];
                            const sectionHeadersOffset = peOffset + 24 + view.getUint16(peOffset + 20, true);
                            
                            for (let i = 0; i < numberOfSections; i++) {
                                const sectionOffset = sectionHeadersOffset + i * 40;
                                
                                // Read section name (8 bytes)
                                let name = '';
                                for (let j = 0; j < 8; j++) {
                                    const char = view.getUint8(sectionOffset + j);
                                    if (char === 0) break;
                                    name += String.fromCharCode(char);
                                }
                                
                                const virtualSize = view.getUint32(sectionOffset + 8, true);
                                const virtualAddress = view.getUint32(sectionOffset + 12, true);
                                const rawDataSize = view.getUint32(sectionOffset + 16, true);
                                const rawDataOffset = view.getUint32(sectionOffset + 20, true);
                                
                                sections.push({
                                    name,
                                    virtualSize,
                                    virtualAddress,
                                    rawDataSize,
                                    rawDataOffset
                                });
                            }
                            
                            // Extract imported functions (simplified)
                            const imports = [
                                { dll: 'kernel32.dll', functions: ['CreateFileA', 'ReadFile', 'WriteFile', 'CloseHandle'] },
                                { dll: 'user32.dll', functions: ['MessageBoxA', 'ShowWindow', 'RegisterClassA'] },
                                { dll: 'gdi32.dll', functions: ['CreateDC', 'BitBlt', 'DeleteDC'] }
                            ];
                            
                            // Extract exported functions (simplified)
                            const exports = [
                                { name: 'Initialize', ordinal: 1 },
                                { name: 'Shutdown', ordinal: 2 },
                                { name: 'Process', ordinal: 3 }
                            ];
                            
                            resolve({
                                type: 'assembly',
                                machine: machine,
                                isDll: isDll,
                                timestamp: new Date(timeDateStamp * 1000).toISOString(),
                                sections: sections,
                                imports: imports,
                                exports: exports,
                                rawBuffer: buffer,
                                metadata: {
                                    format: 'PE',
                                    is64Bit: machine === 0x8664, // 0x8664 = AMD64
                                    isManagedCode: false, // would require checking for CLR header
                                    characteristics: characteristics
                                }
                            });
                        } catch (error) {
                            console.error('Error parsing assembly file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
        };
        
        // Component: File Tree
        const FileTree = ({ files, onFileSelect, selectedFile }) => {
            const [expandedFolders, setExpandedFolders] = useState({});
            
            const toggleFolder = (path) => {
                setExpandedFolders({
                    ...expandedFolders,
                    [path]: !expandedFolders[path]
                });
            };
            
            // Recursive function to render file tree
            const renderTree = (items, path = '') => {
                return Object.keys(items).map(key => {
                    const currentPath = path ? `${path}/${key}` : key;
                    const item = items[key];
                    
                    if (item.type === 'folder') {
                        const isExpanded = expandedFolders[currentPath] !== false;
                        return (
                            <div key={currentPath}>
                                <div 
                                    className="file-tree-item file-tree-folder"
                                    onClick={() => toggleFolder(currentPath)}
                                >
                                    <span>{isExpanded ? '📂' : '📁'} {key}</span>
                                </div>
                                {isExpanded && item.children && (
                                    <div style={{ paddingLeft: '20px' }}>
                                        {renderTree(item.children, currentPath)}
                                    </div>
                                )}
                            </div>
                        );
                    } else {
                        const fileType = getFileType(key);
                        const isSelected = selectedFile === currentPath;
                        return (
                            <div 
                                key={currentPath}
                                className={`file-tree-item ${isSelected ? 'selected' : ''}`}
                                onClick={() => onFileSelect(currentPath, item)}
                            >
                                <span>{fileType.icon} {key}</span>
                            </div>
                        );
                    }
                });
            };
            
            return (
                <div className="file-tree p-2">
                    <h3 className="matrix-title text-sm">Files</h3>
                    {files && Object.keys(files).length > 0 ? (
                        renderTree(files)
                    ) : (
                        <div className="p-4 text-sm">
                            No files loaded. Use the "Load Directory" button above.
                        </div>
                    )}
                </div>
            );
        };
        
        // Component: Model Editor
        const ModelEditor = ({ file, data }) => {
            const containerRef = useRef(null);
            const [scene, setScene] = useState(null);
            const [activeTab, setActiveTab] = useState(data?.initialTab || 'view');
            const [renderMode, setRenderMode] = useState('solid');
            const [showBones, setShowBones] = useState(false);
            const [showAxes, setShowAxes] = useState(true);
            const [animationPlaying, setAnimationPlaying] = useState(false);
            const [currentAnimation, setCurrentAnimation] = useState(0);
            const [modelStats, setModelStats] = useState({
                vertices: 0,
                faces: 0,
                bones: 0,
                animations: 0
            });
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const modelRef = useRef(null);
            const mixerRef = useRef(null);
            
            useEffect(() => {
                if (!containerRef.current) return;
                
                // Wait for THREE.js to be ready
                const initThreeJS = () => {
                    if (!window.THREE) {
                        console.log('Waiting for THREE.js to load...');
                        setTimeout(initThreeJS, 100);
                        return;
                    }
                    
                    // Initialize Three.js
                    const width = containerRef.current.clientWidth;
                    const height = containerRef.current.clientHeight;
                    
                    const scene = new window.THREE.Scene();
                    const camera = new window.THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                
                // Set initial camera position
                camera.position.set(0, 0, 5);
                camera.lookAt(0, 0, 0);
                console.log('Camera created with position:', camera.position);
                
                // Store camera reference globally for access by other components
                window.sceneCamera = camera;
                
                // Enhanced renderer setup based on instructions.txt
                const renderer = new window.THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                
                renderer.setSize(width, height);
                renderer.setClearColor(0x001a00, 1);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = window.THREE.PCFSoftShadowMap;
                renderer.outputColorSpace = window.THREE.SRGBColorSpace;
                renderer.toneMapping = window.THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                
                // Error handling for WebGL context
                renderer.domElement.addEventListener('webglcontextlost', (event) => {
                    event.preventDefault();
                    console.warn('WebGL context lost');
                });
                
                renderer.domElement.addEventListener('webglcontextrestored', () => {
                    console.log('WebGL context restored');
                });
                
                containerRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;
                
                // Define event handlers outside the if block so they're accessible in cleanup
                let onKeyDown, onKeyUp, onMouseDown, onMouseUp, onMouseMove;
                
                // Add controls
                // Make sure THREE.OrbitControls is available
                if (window.THREE && window.THREE.OrbitControls) {
                    console.log('Initializing OrbitControls');
                    const controls = new window.THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.25;
                    
                    // Disable any OrbitControls keyboard handling
                    if (controls.enableKeys !== undefined) {
                        controls.enableKeys = false; // For older THREE.js versions
                    }
                    
                    if (controls.listenToKeyEvents !== undefined) {
                        controls.listenToKeyEvents = null; // For newer THREE.js versions
                    }
                    
                    // Debug camera and controls
                    console.log('Camera initial position:', camera.position);
                    console.log('OrbitControls settings after modification:', {
                        enableDamping: controls.enableDamping,
                        dampingFactor: controls.dampingFactor,
                        enableKeys: controls.enableKeys,
                        listenToKeyEvents: controls.listenToKeyEvents,
                        enabled: controls.enabled
                    });
                    
                    controlsRef.current = controls;
                    
                    // Add WADR movement (W=forward, A=left, D=backward, R=right)
                    const keyStates = {
                        w: false,
                        a: false,
                        d: false,
                        r: false
                    };
                    
                    // Declare event handlers at function scope
                    let onKeyDown, onKeyUp, onMouseDown, onMouseUp, onMouseMove;
                    
                    // Add keyboard event listeners
                    onKeyDown = (event) => {
                        const key = event.key.toLowerCase();
                        console.log('KeyDown Event:', key);
                        if (['w', 'a', 'd', 'r'].includes(key)) {
                            keyStates[key] = true;
                            console.log('KeyStates after keydown:', JSON.stringify(keyStates));
                        }
                    };
                    
                    onKeyUp = (event) => {
                        const key = event.key.toLowerCase();
                        console.log('KeyUp Event:', key);
                        if (['w', 'a', 'd', 'r'].includes(key)) {
                            keyStates[key] = false;
                            console.log('KeyStates after keyup:', JSON.stringify(keyStates));
                        }
                    };
                    
                    // Add mouse rotation (in addition to OrbitControls)
                    const mouseState = {
                        isRotating: false,
                        prevX: 0,
                        prevY: 0
                    };
                    
                    onMouseDown = (event) => {
                        console.log('MouseDown Event:', event.button, event.clientX, event.clientY);
                        if (event.button === 0) { // Left mouse button
                            mouseState.isRotating = true;
                            mouseState.prevX = event.clientX;
                            mouseState.prevY = event.clientY;
                            console.log('Mouse rotation started:', mouseState);
                        }
                    };
                    
                    onMouseUp = (event) => {
                        console.log('MouseUp Event');
                        mouseState.isRotating = false;
                        console.log('Mouse rotation stopped:', mouseState);
                    };
                    
                    onMouseMove = (event) => {
                        if (mouseState.isRotating) {
                            const deltaX = event.clientX - mouseState.prevX;
                            const deltaY = event.clientY - mouseState.prevY;
                            
                            console.log('MouseMove with rotation:', deltaX, deltaY);
                            
                            // Rotate camera based on mouse movement
                            camera.rotation.y -= deltaX * 0.01;
                            camera.rotation.x -= deltaY * 0.01;
                            
                            mouseState.prevX = event.clientX;
                            mouseState.prevY = event.clientY;
                        }
                    };
                    
                    // Add event listeners
                    console.log('Adding event listeners for WASD and mouse rotation');
                    document.addEventListener('keydown', onKeyDown);
                    document.addEventListener('keyup', onKeyUp);
                    renderer.domElement.addEventListener('mousedown', onMouseDown);
                    document.addEventListener('mouseup', onMouseUp);
                    document.addEventListener('mousemove', onMouseMove);
                    
                    // Debug orbit controls settings
                    console.log('OrbitControls settings:', {
                        enableKeys: controls.enableKeys,
                        enableRotate: controls.enableRotate,
                        enablePan: controls.enablePan,
                        enableZoom: controls.enableZoom
                    });
                    
                    // Store reference to key states for animation loop
                    controls.keyStates = keyStates;
                    console.log('Stored keyStates on controls:', controls.keyStates);
                } else {
                    console.warn("THREE.OrbitControls is not available. Using manual mouse controls.");
                    
                    // Manual mouse rotation implementation
                    let mouseDown = false;
                    let mouseX = 0;
                    let mouseY = 0;
                    let cameraDistance = 5;
                    let theta = 0; // Horizontal rotation
                    let phi = Math.PI / 2; // Vertical rotation
                    
                    // Set initial camera position
                    camera.position.set(0, 0, cameraDistance);
                    camera.lookAt(0, 0, 0);
                    
                    const updateCameraPosition = () => {
                        // Convert spherical coordinates to Cartesian
                        camera.position.x = cameraDistance * Math.sin(phi) * Math.cos(theta);
                        camera.position.y = cameraDistance * Math.cos(phi);
                        camera.position.z = cameraDistance * Math.sin(phi) * Math.sin(theta);
                        camera.lookAt(0, 0, 0);
                    };
                    
                    const handleMouseDown = (event) => {
                        if (event.button === 0) { // Left mouse button
                            mouseDown = true;
                            mouseX = event.clientX;
                            mouseY = event.clientY;
                            event.preventDefault();
                        }
                    };
                    
                    const handleMouseUp = () => {
                        mouseDown = false;
                    };
                    
                    const handleMouseMove = (event) => {
                        if (!mouseDown) return;
                        
                        const deltaX = event.clientX - mouseX;
                        const deltaY = event.clientY - mouseY;
                        
                        // Update rotation angles
                        theta -= deltaX * 0.01;
                        phi -= deltaY * 0.01;
                        
                        // Clamp vertical rotation
                        phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                        
                        updateCameraPosition();
                        
                        mouseX = event.clientX;
                        mouseY = event.clientY;
                    };
                    
                    const handleWheel = (event) => {
                        cameraDistance += event.deltaY * 0.01;
                        cameraDistance = Math.max(1, Math.min(20, cameraDistance));
                        updateCameraPosition();
                        event.preventDefault();
                    };
                    
                    renderer.domElement.addEventListener('mousedown', handleMouseDown);
                    window.addEventListener('mouseup', handleMouseUp);
                    window.addEventListener('mousemove', handleMouseMove);
                    renderer.domElement.addEventListener('wheel', handleWheel);
                    
                    // Store cleanup function
                    controlsRef.current = {
                        update: () => {}, // No-op for compatibility
                        dispose: () => {
                            renderer.domElement.removeEventListener('mousedown', handleMouseDown);
                            window.removeEventListener('mouseup', handleMouseUp);
                            window.removeEventListener('mousemove', handleMouseMove);
                            renderer.domElement.removeEventListener('wheel', handleWheel);
                        }
                    };
                }
                
                // Enhanced lighting setup based on instructions.txt
                const ambientLight = new window.THREE.AmbientLight(0x404040, 0.4);
                scene.add(ambientLight);
                
                const directionalLight = new window.THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                scene.add(directionalLight);
                
                // Add additional point light for better illumination
                const pointLight = new window.THREE.PointLight(0x00ff00, 0.3, 100);
                pointLight.position.set(-5, 5, 5);
                scene.add(pointLight);
                
                // Add fill light
                const fillLight = new window.THREE.DirectionalLight(0x004400, 0.3);
                fillLight.position.set(-1, -1, -1);
                scene.add(fillLight);
                
                // Add axes helper
                const axesHelper = new window.THREE.AxesHelper(5);
                scene.add(axesHelper);
                
                // Add a grid
                const gridHelper = new window.THREE.GridHelper(10, 10, 0x00ff00, 0x004400);
                scene.add(gridHelper);
                
                // Check if we have actual model data, otherwise use placeholder
                if (data && data.type === 'model' && data.vertices && data.vertices.length > 0) {
                    // Create a geometry from the parsed data
                    const geometry = new window.THREE.BufferGeometry();
                    
                    // Add vertices
                    if (data.vertices.length > 0) {
                        const vertices = new Float32Array(data.vertices);
                        geometry.setAttribute('position', new window.THREE.BufferAttribute(vertices, 3));
                        
                        // Normalize geometry to prevent extreme stretching
                        geometry.computeBoundingBox();
                        const bbox = geometry.boundingBox;
                        const center = new window.THREE.Vector3();
                        bbox.getCenter(center);
                        geometry.translate(-center.x, -center.y, -center.z);
                        
                        // Scale to fit within reasonable bounds (keeping MXO scale in mind)
                        const size = new window.THREE.Vector3();
                        bbox.getSize(size);
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        // MXO models are already scaled (1cm = 0.01m), so only scale if extremely large
                        if (maxDim > 50) { // 50 meters is extremely large for a game model
                            const scale = 10 / maxDim;
                            geometry.scale(scale, scale, scale);
                            console.log(`Model scaled down by factor of ${scale} (was ${maxDim}m)`);
                        } else if (maxDim < 0.1) { // Less than 10cm is too small
                            const scale = 1 / maxDim;
                            geometry.scale(scale, scale, scale);
                            console.log(`Model scaled up by factor of ${scale} (was ${maxDim}m)`);
                        }
                    }
                    
                    // Add UVs if available
                    if (data.uvs && data.uvs.length > 0) {
                        const uvs = new Float32Array(data.uvs);
                        geometry.setAttribute('uv', new window.THREE.BufferAttribute(uvs, 2));
                    }
                    
                    // Add normals if available
                    if (data.normals && data.normals.length > 0) {
                        const normals = new Float32Array(data.normals);
                        geometry.setAttribute('normal', new window.THREE.BufferAttribute(normals, 3));
                    } else {
                        // Compute normals if not provided
                        geometry.computeVertexNormals();
                    }
                    
                    // Add indices if available
                    if (data.indices && data.indices.length > 0) {
                        geometry.setIndex(data.indices);
                    }
                    
                    // Enhanced material based on instructions.txt
                    const material = new window.THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        wireframe: renderMode === 'wireframe',
                        side: window.THREE.DoubleSide,
                        shininess: 30,
                        specular: 0x222222,
                        transparent: false,
                        opacity: 1.0
                    });
                    
                    // Apply texture if available in MOB data
                    if (data.texture) {
                        const textureLoader = new window.THREE.TextureLoader();
                        material.map = textureLoader.load(data.texture);
                    }
                    
                    // Create mesh
                    const mesh = new window.THREE.Mesh(geometry, material);
                    
                    // Check if we have LOD levels
                    if (data.lodLevels && data.lodLevels.length > 1) {
                        // Create LOD object
                        const lod = new window.THREE.LOD();
                        
                        data.lodLevels.forEach((level, index) => {
                            const lodGeometry = new window.THREE.BufferGeometry();
                            
                            // Apply vertex reduction if this is a simplified LOD
                            let lodVertices = level.vertices;
                            let lodIndices = level.indices;
                            
                            if (level.simplified && level.reduction) {
                                // Simple vertex reduction (in real implementation, use proper decimation)
                                const step = Math.floor(1 / level.reduction);
                                lodVertices = [];
                                lodIndices = [];
                                
                                for (let i = 0; i < level.vertices.length; i += step * 3) {
                                    if (i + 2 < level.vertices.length) {
                                        lodVertices.push(level.vertices[i], level.vertices[i+1], level.vertices[i+2]);
                                    }
                                }
                                
                                // Regenerate indices
                                const numVerts = lodVertices.length / 3;
                                for (let i = 0; i < numVerts - 2; i += 3) {
                                    if (i + 2 < numVerts) {
                                        lodIndices.push(i, i + 1, i + 2);
                                    }
                                }
                            }
                            
                            lodGeometry.setAttribute('position', new window.THREE.BufferAttribute(new Float32Array(lodVertices), 3));
                            if (lodIndices.length > 0) {
                                lodGeometry.setIndex(lodIndices);
                            }
                            lodGeometry.computeVertexNormals();
                            
                            const lodMaterial = material.clone();
                            if (index > 0) {
                                // Make lower LODs slightly different color for debugging
                                lodMaterial.color.multiplyScalar(0.8);
                            }
                            
                            const lodMesh = new window.THREE.Mesh(lodGeometry, lodMaterial);
                            lod.addLevel(lodMesh, level.distance);
                        });
                        
                        scene.add(lod);
                        modelRef.current = lod;
                        
                        // Update camera for LOD testing
                        lod.update(camera);
                    } else {
                        // No LOD, add single mesh
                        scene.add(mesh);
                        modelRef.current = mesh;
                    }
                    
                    // Calculate statistics
                    setModelStats({
                        vertices: data.vertices.length / 3,
                        faces: data.indices ? data.indices.length / 3 : data.vertices.length / 9,
                        bones: data.bones ? data.bones.length : 0,
                        animations: data.animations ? data.animations.length : 0,
                        lodLevels: data.lodLevels ? data.lodLevels.length : 1
                    });
                    
                    // Add animations if available
                    if (data.animations && data.animations.length > 0) {
                        const mixer = new window.THREE.AnimationMixer(mesh);
                        mixerRef.current = mixer;
                        
                        // Convert animations to THREE.js format
                        // (simplified - in a real implementation this would parse the actual animation data)
                        const clip = window.THREE.AnimationClip.parseAnimation({
                            hierarchy: [{
                                keys: [
                                    { time: 0, pos: [0, 0, 0], rot: [0, 0, 0, 1], scl: [1, 1, 1] },
                                    { time: 1, pos: [0, 1, 0], rot: [0, 0, 0, 1], scl: [1, 1, 1] },
                                    { time: 2, pos: [0, 0, 0], rot: [0, 0, 0, 1], scl: [1, 1, 1] }
                                ]
                            }]
                        }, data.bones || []);
                        
                        mixer.clipAction(clip).play();
                    }
                } else {
                    // Add a placeholder model (character-like figure)
                    const characterGroup = new window.THREE.Group();
                    
                    // Body
                    const bodyGeometry = new window.THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
                    const bodyMaterial = new window.THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        wireframe: renderMode === 'wireframe'
                    });
                    const body = new window.THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1.5;
                    characterGroup.add(body);
                    
                    // Head
                    const headGeometry = new window.THREE.SphereGeometry(0.4, 16, 16);
                    const headMaterial = new window.THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        wireframe: renderMode === 'wireframe' 
                    });
                    const head = new window.THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 2.8;
                    characterGroup.add(head);
                    
                    // Arms
                    const armGeometry = new window.THREE.CapsuleGeometry(0.2, 1, 4, 8);
                    const armMaterial = new window.THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        wireframe: renderMode === 'wireframe'
                    });
                    
                    const rightArm = new window.THREE.Mesh(armGeometry, armMaterial);
                    rightArm.position.set(0.8, 1.8, 0);
                    rightArm.rotation.z = Math.PI / 2.5;
                    characterGroup.add(rightArm);
                    
                    const leftArm = new window.THREE.Mesh(armGeometry, armMaterial);
                    leftArm.position.set(-0.8, 1.8, 0);
                    leftArm.rotation.z = -Math.PI / 2.5;
                    characterGroup.add(leftArm);
                    
                    // Legs
                    const legGeometry = new window.THREE.CapsuleGeometry(0.25, 1.2, 4, 8);
                    const legMaterial = new window.THREE.MeshPhongMaterial({ 
                        color: 0x00ff00,
                        wireframe: renderMode === 'wireframe'
                    });
                    
                    const rightLeg = new window.THREE.Mesh(legGeometry, legMaterial);
                    rightLeg.position.set(0.3, 0.6, 0);
                    characterGroup.add(rightLeg);
                    
                    const leftLeg = new window.THREE.Mesh(legGeometry, legMaterial);
                    leftLeg.position.set(-0.3, 0.6, 0);
                    characterGroup.add(leftLeg);
                    
                    scene.add(characterGroup);
                    modelRef.current = characterGroup;
                    
                    // Set mock stats
                    setModelStats({
                        vertices: 1024,
                        faces: 512,
                        bones: 16,
                        animations: 5
                    });
                    
                    // Add mock animation mixer
                    const mixer = new window.THREE.AnimationMixer(characterGroup);
                    mixerRef.current = mixer;
                    
                    // Mock animation for the character
                    const idleAnimation = {
                        name: 'idle',
                        duration: 2,
                        update: (time) => {
                            const t = time % 2;
                            const y = Math.sin(t * Math.PI) * 0.1;
                            characterGroup.position.y = y;
                            
                            // Breathe effect
                            const scale = 1 + Math.sin(t * Math.PI) * 0.02;
                            body.scale.set(1, scale, 1);
                            
                            // Arm swing
                            rightArm.rotation.z = Math.PI / 2.5 + Math.sin(t * Math.PI) * 0.1;
                            leftArm.rotation.z = -Math.PI / 2.5 - Math.sin(t * Math.PI) * 0.1;
                        }
                    };
                    
                    // Store animation
                    characterGroup.userData.animations = [idleAnimation];
                }
                
                // Position camera
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 1, 0);
                
                // Animation clock
                const clock = new window.THREE.Clock();
                
                // Create a global keyboard state object on the window
                window.keyboardState = {
                    w: false,
                    a: false,
                    d: false,
                    r: false
                };
                
                // Track camera movement speed
                window.moveSpeed = 0.2; // Larger speed for more noticeable movement
                
                // Simple global keyboard controls - W=forward, A=left, D=backward, R=right
                const handleKeyDown = function(e) {
                    const key = e.key.toLowerCase();
                    if (['w', 'a', 'd', 'r'].includes(key)) {
                        window.keyboardState[key] = true;
                        console.log('Key pressed:', key, window.keyboardState);
                    }
                };
                
                const handleKeyUp = function(e) {
                    const key = e.key.toLowerCase();
                    if (['w', 'a', 'd', 'r'].includes(key)) {
                        window.keyboardState[key] = false;
                        console.log('Key released:', key, window.keyboardState);
                    }
                };
                
                // Remove any existing global keyboard handlers to avoid conflicts
                if (window.myKeyDownHandler) {
                    window.removeEventListener('keydown', window.myKeyDownHandler);
                }
                if (window.myKeyUpHandler) {
                    window.removeEventListener('keyup', window.myKeyUpHandler);
                }
                
                // Add our listeners
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                
                // Store references to our handlers for later cleanup
                window.myKeyDownHandler = handleKeyDown;
                window.myKeyUpHandler = handleKeyUp;
                
                console.log("Global keyboard controls initialized");
                
                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // Update controls
                    if (controlsRef.current) {
                        controlsRef.current.update();
                    }
                    
                    // Update LOD if we have a LOD object
                    if (modelRef.current && modelRef.current.isLOD) {
                        modelRef.current.update(camera);
                    }
                    
                    // Apply camera movement from global keyboard state
                    // Movement is relative to camera direction
                    if (window.keyboardState) {
                        const moveSpeed = window.moveSpeed || 0.2;
                        
                        let moved = false;
                        
                        // W = forward (move in the direction camera is facing)
                        if (window.keyboardState.w) {
                            camera.translateZ(-moveSpeed);
                            moved = true;
                        }
                        
                        // D = backward (move away from the direction camera is facing)
                        if (window.keyboardState.d) {
                            camera.translateZ(moveSpeed);
                            moved = true;
                        }
                        
                        // A = left (strafe left)
                        if (window.keyboardState.a) {
                            camera.translateX(-moveSpeed);
                            moved = true;
                        }
                        
                        // R = right (strafe right)
                        if (window.keyboardState.r) {
                            camera.translateX(moveSpeed);
                            moved = true;
                        }
                        
                        if (moved) {
                            // Store camera position on window for access from other components
                            window.cameraPosition = {
                                x: camera.position.x,
                                y: camera.position.y,
                                z: camera.position.z
                            };
                            
                            console.log('Camera moved to:', 
                                camera.position.x.toFixed(2), 
                                camera.position.y.toFixed(2), 
                                camera.position.z.toFixed(2));
                            
                            // Force camera update
                            camera.updateMatrixWorld(true);
                            camera.updateProjectionMatrix();
                        }
                    }
                    
                    // Update animations
                    const delta = clock.getDelta();
                    
                    if (mixerRef.current && animationPlaying) {
                        mixerRef.current.update(delta);
                    }
                    
                    // For mock animations
                    if (modelRef.current && 
                        modelRef.current.userData && 
                        modelRef.current.userData.animations && 
                        animationPlaying) {
                        const anim = modelRef.current.userData.animations[currentAnimation];
                        if (anim && anim.update) {
                            anim.update(clock.elapsedTime);
                        }
                    }
                    
                    // Render
                    renderer.render(scene, camera);
                };
                
                animate();
                setScene(scene);
                
                // Handle window resize
                const handleResize = () => {
                    const width = containerRef.current.clientWidth;
                    const height = containerRef.current.clientHeight;
                    
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    
                    renderer.setSize(width, height);
                };
                
                window.addEventListener('resize', handleResize);
                
                // Cleanup on unmount
                return () => {
                    console.log('Component unmounting, cleaning up listeners');
                    window.removeEventListener('resize', handleResize);
                    
                    // Remove global keyboard handlers
                    if (window.myKeyDownHandler) {
                        window.removeEventListener('keydown', window.myKeyDownHandler);
                        window.myKeyDownHandler = null;
                    }
                    if (window.myKeyUpHandler) {
                        window.removeEventListener('keyup', window.myKeyUpHandler);
                        window.myKeyUpHandler = null;
                    }
                    
                    // Remove OrbitControls event listeners if they exist
                    try {
                        if (window.THREE && window.THREE.OrbitControls) {
                            // Remove local event listeners added for OrbitControls
                            if (typeof onKeyDown !== 'undefined') {
                                console.log('Removing OrbitControls keyboard and mouse event listeners');
                                document.removeEventListener('keydown', onKeyDown);
                                document.removeEventListener('keyup', onKeyUp);
                                if (renderer && renderer.domElement) {
                                    renderer.domElement.removeEventListener('mousedown', onMouseDown);
                                }
                                document.removeEventListener('mouseup', onMouseUp);
                                document.removeEventListener('mousemove', onMouseMove);
                            }
                        }
                        
                        // Dispose of controls
                        if (controlsRef.current && controlsRef.current.dispose) {
                            controlsRef.current.dispose();
                        }
                    } catch (e) {
                        console.error('Error cleaning up event listeners:', e);
                    }
                    
                    if (containerRef.current && containerRef.current.contains(renderer.domElement)) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                    
                    renderer.dispose();
                    if (mixerRef.current) {
                        mixerRef.current.stopAllAction();
                    }
                };
                
                }; // End of initThreeJS function
                
                // Call initThreeJS to start initialization
                initThreeJS();
                
            }, [containerRef, data, renderMode, showAxes]);
            
            // Toggle wireframe mode
            const toggleRenderMode = () => {
                const newMode = renderMode === 'solid' ? 'wireframe' : 'solid';
                setRenderMode(newMode);
                
                // Update materials on the model
                if (modelRef.current) {
                    modelRef.current.traverse((child) => {
                        if (child.isMesh) {
                            child.material.wireframe = newMode === 'wireframe';
                        }
                    });
                }
            };
            
            // Toggle animation playback
            const toggleAnimation = () => {
                setAnimationPlaying(!animationPlaying);
                
                if (mixerRef.current) {
                    if (!animationPlaying) {
                        // Resume animation
                        mixerRef.current.timeScale = 1;
                    } else {
                        // Pause animation
                        mixerRef.current.timeScale = 0;
                    }
                }
            };
            
            // Change animation
            const changeAnimation = (index) => {
                setCurrentAnimation(index);
                
                if (mixerRef.current) {
                    mixerRef.current.stopAllAction();
                    
                    // In a real implementation, we would play the selected animation
                    // This is simplified for the demo
                    if (animationPlaying) {
                        // Placeholder for animation switching
                        console.log(`Switched to animation ${index}`);
                    }
                }
            };
            
            // Toggle axes visibility
            const toggleAxes = () => {
                setShowAxes(!showAxes);
                
                if (scene) {
                    scene.children.forEach(child => {
                        if (child.isAxesHelper) {
                            child.visible = !showAxes;
                        }
                    });
                }
            };
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Model Editor: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs">Export</button>
                            <button className="matrix-button m-2 text-xs">Save</button>
                        </div>
                    </div>
                    
                    {/* Tabs */}
                    <div className="border-b border-green-900">
                        <div className="flex">
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'view' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('view')}
                            >
                                3D View
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'animation' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('animation')}
                            >
                                Animation
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'info' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('info')}
                            >
                                Info
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'gameobject' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('gameobject')}
                            >
                                GameObject
                            </div>
                        </div>
                    </div>
                    
                    {activeTab === 'view' && (
                        <div className="relative" style={{ height: 'calc(100% - 80px)' }}>
                            <div 
                                ref={containerRef} 
                                className="webgl-container"
                                style={{ height: '100%' }}
                                onMouseEnter={() => {
                                    console.log('Mouse entered 3D view - setting up global keyboard controls');
                                    // Initialize global WASD controls when mouse enters the 3D view
                                    window.keyboardState = window.keyboardState || {
                                        w: false,
                                        a: false,
                                        s: false,
                                        d: false
                                    };
                                    
                                    // Direct keyboard control
                                    const handleKeyDown = function(e) {
                                        const key = e.key.toLowerCase();
                                        if (['w', 'a', 's', 'd'].includes(key)) {
                                            window.keyboardState[key] = true;
                                            console.log('Key pressed in viewer:', key);
                                        }
                                    };
                                    
                                    const handleKeyUp = function(e) {
                                        const key = e.key.toLowerCase();
                                        if (['w', 'a', 's', 'd'].includes(key)) {
                                            window.keyboardState[key] = false;
                                            console.log('Key released in viewer:', key);
                                        }
                                    };
                                    
                                    window.addEventListener('keydown', handleKeyDown);
                                    window.addEventListener('keyup', handleKeyUp);
                                }}
                            ></div>
                            
                            <div className="absolute top-4 right-4 bg-black bg-opacity-50 p-2 rounded">
                                <button 
                                    className="matrix-button mb-2 text-xs w-full"
                                    onClick={toggleRenderMode}
                                >
                                    {renderMode === 'solid' ? 'Wireframe' : 'Solid'}
                                </button>
                                <button 
                                    className="matrix-button mb-2 text-xs w-full"
                                    onClick={toggleAxes}
                                >
                                    {showAxes ? 'Hide Axes' : 'Show Axes'}
                                </button>
                                <button 
                                    className="matrix-button mb-2 text-xs w-full"
                                    onClick={toggleAnimation}
                                >
                                    {animationPlaying ? 'Pause' : 'Animate'}
                                </button>
                                <button 
                                    className="matrix-button mb-2 text-xs w-full"
                                    onClick={() => {
                                        if (scene) {
                                            const lights = scene.children.filter(child => child.isLight);
                                            lights.forEach(light => {
                                                light.visible = !light.visible;
                                            });
                                        }
                                    }}
                                >
                                    Toggle Lights
                                </button>
                                <button 
                                    className="matrix-button text-xs w-full"
                                    onClick={() => {
                                        // Export model to .obj format
                                        if (modelRef.current) {
                                            const objData = exportToOBJ(modelRef.current);
                                            const blob = new Blob([objData], { type: 'text/plain' });
                                            const url = URL.createObjectURL(blob);
                                            const link = document.createElement('a');
                                            link.href = url;
                                            link.download = file.name.replace(/\.[^/.]+$/, '') + '.obj';
                                            document.body.appendChild(link);
                                            link.click();
                                            document.body.removeChild(link);
                                            URL.revokeObjectURL(url);
                                        }
                                    }}
                                >
                                    Export OBJ
                                </button>
                            </div>
                            
                            <div className="absolute bottom-4 left-4 text-xs">
                                <p>Left click + drag: Rotate</p>
                                <p>Right click + drag: Pan</p>
                                <p>Scroll: Zoom</p>
                                <p>W: Forward, A: Left, D: Backward, R: Right</p>
                                
                                {/* Visual key press indicator */}
                                <div style={{ marginTop: '1rem', border: '1px solid #00ff00', padding: '0.5rem' }}>
                                    <p>Key status:</p>
                                    <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.25rem' }}>
                                        <div style={{ 
                                            width: '1.5rem', 
                                            height: '1.5rem', 
                                            backgroundColor: window.keyboardState && window.keyboardState['w'] ? '#00ff00' : 'transparent',
                                            border: '1px solid #00ff00',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}>W</div>
                                        <div style={{ 
                                            width: '1.5rem', 
                                            height: '1.5rem', 
                                            backgroundColor: window.keyboardState && window.keyboardState['a'] ? '#00ff00' : 'transparent',
                                            border: '1px solid #00ff00',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}>A</div>
                                        <div style={{ 
                                            width: '1.5rem', 
                                            height: '1.5rem', 
                                            backgroundColor: window.keyboardState && window.keyboardState['d'] ? '#00ff00' : 'transparent',
                                            border: '1px solid #00ff00',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}>D</div>
                                        <div style={{ 
                                            width: '1.5rem', 
                                            height: '1.5rem', 
                                            backgroundColor: window.keyboardState && window.keyboardState['r'] ? '#00ff00' : 'transparent',
                                            border: '1px solid #00ff00',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}>R</div>
                                    </div>
                                    <p style={{ marginTop: '0.25rem', fontSize: '0.7rem' }}>
                                        Camera controls active
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {activeTab === 'animation' && (
                        <div className="p-4" style={{ height: 'calc(100% - 80px)', overflowY: 'auto' }}>
                            <h4 className="text-sm font-bold mb-4">Animation Controls</h4>
                            
                            <div className="mb-6">
                                <button 
                                    className={`matrix-button m-2 ${animationPlaying ? 'bg-red-900' : ''}`}
                                    onClick={toggleAnimation}
                                >
                                    {animationPlaying ? 'Stop Animation' : 'Play Animation'}
                                </button>
                            </div>
                            
                            <h4 className="text-sm font-bold mb-2">Available Animations</h4>
                            <div className="grid grid-cols-1 gap-2">
                                {['Idle', 'Walk', 'Run', 'Jump', 'Attack'].map((anim, index) => (
                                    <div 
                                        key={index}
                                        className={`p-2 cursor-pointer border ${
                                            currentAnimation === index ? 'border-green-500 bg-green-900 bg-opacity-20' : 'border-gray-700'
                                        }`}
                                        onClick={() => changeAnimation(index)}
                                    >
                                        <p className="font-bold">{anim}</p>
                                        <p className="text-xs">Duration: {(index + 1) * 0.5}s</p>
                                    </div>
                                ))}
                            </div>
                            
                            <div className="mt-8 p-4 bg-black bg-opacity-20">
                                <h4 className="text-sm font-bold mb-2">Animation Blending</h4>
                                <p className="text-xs mb-4">
                                    Adjust the blending between animations for smooth transitions.
                                </p>
                                
                                <div className="mb-2">
                                    <label className="text-xs block mb-1">Blend Factor</label>
                                    <input 
                                        type="range" 
                                        min="0" 
                                        max="1" 
                                        step="0.01" 
                                        defaultValue="0.5"
                                        className="w-full"
                                    />
                                </div>
                                
                                <div className="mb-2">
                                    <label className="text-xs block mb-1">Transition Duration</label>
                                    <input 
                                        type="range" 
                                        min="0" 
                                        max="2" 
                                        step="0.1" 
                                        defaultValue="0.5"
                                        className="w-full"
                                    />
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {activeTab === 'info' && (
                        <div className="p-4" style={{ height: 'calc(100% - 80px)', overflowY: 'auto' }}>
                            <h4 className="text-sm font-bold mb-4">Model Information</h4>
                            
                            <div className="grid grid-cols-2 gap-4 mb-6">
                                <div className="bg-black bg-opacity-20 p-4 rounded">
                                    <h5 className="text-sm font-bold mb-2">Geometry</h5>
                                    <p className="text-xs"><strong>Vertices:</strong> {modelStats.vertices}</p>
                                    <p className="text-xs"><strong>Faces:</strong> {modelStats.faces}</p>
                                    <p className="text-xs"><strong>Bones:</strong> {modelStats.bones}</p>
                                </div>
                                
                                <div className="bg-black bg-opacity-20 p-4 rounded">
                                    <h5 className="text-sm font-bold mb-2">Animation</h5>
                                    <p className="text-xs"><strong>Animations:</strong> {modelStats.animations}</p>
                                    <p className="text-xs"><strong>Format:</strong> {
                                        file.name.toLowerCase().endsWith('.abc') ? 'Lithtech ABC' : 
                                        file.name.toLowerCase().endsWith('.moa') ? 'MOA - Character/Clothing/Vehicle' :
                                        file.name.toLowerCase().endsWith('.prop') ? 'PROP - Static Object' :
                                        file.name.toLowerCase().endsWith('.iprf') ? 'IPRF - Specialized Data' :
                                        file.name.toLowerCase().endsWith('.eprf') ? 'EPRF - Specialized Data' :
                                        file.name.toLowerCase().endsWith('.mga') ? 'MGA - Model Group' :
                                        file.name.toLowerCase().endsWith('.mgc') ? 'MGC - Model Collection' :
                                        'Matrix Online Model'
                                    }</p>
                                </div>
                            </div>
                            
                            <h4 className="text-sm font-bold mb-2">Matrix Online Model Format</h4>
                            <p className="text-xs mb-4">
                                {file.name.toLowerCase().endsWith('.abc') ? (
                                    <>
                                        ABC (Actor Binary Cache) files store 3D models used in The Matrix Online. 
                                        They contain meshes, skeletons, animations, and material definitions.
                                        These files are optimized for the Lithtech engine.
                                    </>
                                ) : file.name.toLowerCase().endsWith('.moa') ? (
                                    <>
                                        MOA files contain character models, clothing, and vehicles with multiple LOD levels.
                                        These are index files that reference other assets. Essential for animated characters
                                        as they include bone weights and skeletal data.
                                    </>
                                ) : file.name.toLowerCase().endsWith('.prop') ? (
                                    <>
                                        PROP files contain static props and objects in the game world.
                                        These are simpler than character models and don't require bone weight data.
                                        Ideal for environmental objects and decorations.
                                    </>
                                ) : file.name.toLowerCase().endsWith('.mga') || file.name.toLowerCase().endsWith('.mgc') ? (
                                    <>
                                        Model Group/Collection files organize multiple models together.
                                        These files reference other model assets and are used for complex objects
                                        that consist of multiple parts.
                                    </>
                                ) : file.name.toLowerCase().endsWith('.iprf') || file.name.toLowerCase().endsWith('.eprf') ? (
                                    <>
                                        Specialized model data files used in Matrix Online.
                                        IPRF (Internal Performance) and EPRF (External Performance) files contain
                                        optimized model data for specific game systems.
                                    </>
                                ) : (
                                    <>
                                        Matrix Online uses a modified Lithtech Discovery engine with unique file formats.
                                        Scale: 1 unit = 1 centimeter. Models include UV coordinates, normals, and 
                                        bone weights (for animated models).
                                    </>
                                )}
                            </p>
                            
                            <h4 className="text-sm font-bold mb-2 mt-6">Technical Details</h4>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <tbody>
                                    <tr>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>File Size</td>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                            {file.size} bytes
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Mesh Count</td>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                            1
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Material Count</td>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                            1
                                        </td>
                                    </tr>
                                    <tr>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>UV Channels</td>
                                        <td style={{ padding: '4px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                            1
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    )}
                    
                    {activeTab === 'gameobject' && (
                        <div className="p-4" style={{ height: 'calc(100% - 80px)', overflowY: 'auto' }}>
                            <h4 className="text-sm font-bold mb-4">GameObject Properties</h4>
                            
                            <div className="mb-6">
                                <h5 className="text-sm font-bold mb-2">Transform</h5>
                                <div className="bg-black bg-opacity-20 p-4 rounded">
                                    <div className="grid grid-cols-3 gap-2 mb-2">
                                        <div>
                                            <label className="text-xs block mb-1">Position X</label>
                                            <input type="number" defaultValue="0" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                        <div>
                                            <label className="text-xs block mb-1">Position Y</label>
                                            <input type="number" defaultValue="0" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                        <div>
                                            <label className="text-xs block mb-1">Position Z</label>
                                            <input type="number" defaultValue="0" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-3 gap-2 mb-2">
                                        <div>
                                            <label className="text-xs block mb-1">Rotation X</label>
                                            <input type="number" defaultValue="0" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                        <div>
                                            <label className="text-xs block mb-1">Rotation Y</label>
                                            <input type="number" defaultValue="0" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                        <div>
                                            <label className="text-xs block mb-1">Rotation Z</label>
                                            <input type="number" defaultValue="0" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-3 gap-2">
                                        <div>
                                            <label className="text-xs block mb-1">Scale X</label>
                                            <input type="number" defaultValue="1" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                        <div>
                                            <label className="text-xs block mb-1">Scale Y</label>
                                            <input type="number" defaultValue="1" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                        <div>
                                            <label className="text-xs block mb-1">Scale Z</label>
                                            <input type="number" defaultValue="1" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="mb-6">
                                <h5 className="text-sm font-bold mb-2">Components</h5>
                                <div className="bg-black bg-opacity-20 p-4 rounded">
                                    <div className="mb-3">
                                        <div className="flex items-center mb-2">
                                            <input type="checkbox" defaultChecked className="mr-2" />
                                            <span className="text-xs font-bold">Mesh Renderer</span>
                                        </div>
                                        <div className="pl-6">
                                            <p className="text-xs"><strong>Mesh:</strong> {file.name}</p>
                                            <p className="text-xs"><strong>Material:</strong> Default Matrix Material</p>
                                        </div>
                                    </div>
                                    
                                    <div className="mb-3">
                                        <div className="flex items-center mb-2">
                                            <input type="checkbox" className="mr-2" />
                                            <span className="text-xs font-bold">Collider</span>
                                        </div>
                                        <div className="pl-6">
                                            <select className="bg-gray-900 border border-green-700 px-2 py-1 text-xs">
                                                <option>Box Collider</option>
                                                <option>Sphere Collider</option>
                                                <option>Mesh Collider</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div className="mb-3">
                                        <div className="flex items-center mb-2">
                                            <input type="checkbox" className="mr-2" />
                                            <span className="text-xs font-bold">Physics Body</span>
                                        </div>
                                        <div className="pl-6">
                                            <label className="text-xs block mb-1">Mass</label>
                                            <input type="number" defaultValue="1" className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs mb-2" />
                                            <div className="flex items-center">
                                                <input type="checkbox" className="mr-2" />
                                                <span className="text-xs">Use Gravity</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <button className="matrix-button text-xs mt-2">Add Component</button>
                                </div>
                            </div>
                            
                            <div className="mb-6">
                                <h5 className="text-sm font-bold mb-2">Tags & Layers</h5>
                                <div className="bg-black bg-opacity-20 p-4 rounded">
                                    <div className="mb-2">
                                        <label className="text-xs block mb-1">Tag</label>
                                        <select className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs">
                                            <option>Untagged</option>
                                            <option>Player</option>
                                            <option>Enemy</option>
                                            <option>Environment</option>
                                            <option>Collectible</option>
                                        </select>
                                    </div>
                                    
                                    <div>
                                        <label className="text-xs block mb-1">Layer</label>
                                        <select className="w-full bg-gray-900 border border-green-700 px-2 py-1 text-xs">
                                            <option>Default</option>
                                            <option>UI</option>
                                            <option>Physics</option>
                                            <option>Transparent</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="flex gap-2">
                                <button className="matrix-button text-xs">Apply Changes</button>
                                <button className="matrix-button text-xs">Reset</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        
        // Component: Texture Editor
        const TextureEditor = ({ file, data }) => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current || !data || !data.canvas) return;
                
                const context = canvasRef.current.getContext('2d');
                
                // Copy from the data canvas to our display canvas
                canvasRef.current.width = data.width;
                canvasRef.current.height = data.height;
                context.drawImage(data.canvas, 0, 0);
                
            }, [canvasRef, data]);
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Texture Editor: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs">Export</button>
                            <button className="matrix-button m-2 text-xs">Save</button>
                        </div>
                    </div>
                    <div className="p-4 flex items-center justify-center" style={{ height: 'calc(100% - 40px)' }}>
                        <canvas 
                            ref={canvasRef} 
                            style={{ 
                                maxWidth: '100%', 
                                maxHeight: '100%', 
                                border: '1px solid #00ff00' 
                            }}
                        ></canvas>
                    </div>
                </div>
            );
        };
        
        // Component: Level Editor
        const LevelEditor = ({ file, data }) => {
            const containerRef = useRef(null);
            
            useEffect(() => {
                if (!containerRef.current) return;
                
                // Initialize Three.js for level editing
                const width = containerRef.current.clientWidth;
                const height = containerRef.current.clientHeight;
                
                const scene = new window.THREE.Scene();
                const camera = new window.THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                const renderer = new window.THREE.WebGLRenderer({ antialias: true });
                
                renderer.setSize(width, height);
                renderer.setClearColor(0x001a00, 1);
                containerRef.current.appendChild(renderer.domElement);
                
                // Add controls
                const controls = new window.THREE.OrbitControls(camera, renderer.domElement);
                
                // Add lighting
                const ambientLight = new window.THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new window.THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // Add a placeholder level grid
                const gridHelper = new window.THREE.GridHelper(100, 100, 0x00ff00, 0x004400);
                scene.add(gridHelper);
                
                // Add placeholder level geometry
                const geometry = new window.THREE.BoxGeometry(10, 1, 10);
                const material = new window.THREE.MeshPhongMaterial({ 
                    color: 0x00ff00,
                    wireframe: false
                });
                const platform = new window.THREE.Mesh(geometry, material);
                platform.position.y = -0.5;
                scene.add(platform);
                
                // Position camera
                camera.position.set(10, 10, 10);
                camera.lookAt(0, 0, 0);
                
                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                
                animate();
                
                // Cleanup on unmount
                return () => {
                    if (containerRef.current && containerRef.current.contains(renderer.domElement)) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                    renderer.dispose();
                };
            }, [containerRef, data]);
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Level Editor: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs">Export</button>
                            <button className="matrix-button m-2 text-xs">Save</button>
                        </div>
                    </div>
                    <div 
                        ref={containerRef} 
                        className="webgl-container"
                        style={{ height: 'calc(100% - 40px)' }}
                    ></div>
                </div>
            );
        };
        
        // Component: Text Editor (for scripts, messages, etc.)
        const TextEditor = ({ file, data, onSave }) => {
            const containerRef = useRef(null);
            const editorRef = useRef(null);
            const [content, setContent] = useState('');
            
            useEffect(() => {
                if (!containerRef.current) return;
                
                // Initialize Monaco Editor
                require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs' }});
                require(['vs/editor/editor.main'], () => {
                    if (editorRef.current) {
                        editorRef.current.dispose();
                    }
                    
                    // Determine language based on file extension
                    let language = 'plaintext';
                    if (file.name.endsWith('.lua')) language = 'lua';
                    else if (file.name.endsWith('.cs')) language = 'csharp';
                    else if (file.name.endsWith('.xml')) language = 'xml';
                    else if (file.name.endsWith('.json')) language = 'json';
                    
                    // Set initial content
                    let initialContent = '';
                    if (data && data.content) {
                        initialContent = data.content;
                    } else if (typeof data === 'string') {
                        initialContent = data;
                    }
                    
                    setContent(initialContent);
                    
                    // Create editor
                    editorRef.current = monaco.editor.create(containerRef.current, {
                        value: initialContent,
                        language: language,
                        theme: 'vs-dark',
                        minimap: { enabled: true },
                        automaticLayout: true,
                        fontSize: 14,
                        lineNumbers: 'on',
                        scrollBeyondLastLine: false,
                        roundedSelection: false,
                        readOnly: false,
                        cursorStyle: 'line',
                        selectOnLineNumbers: true,
                        wordWrap: 'on'
                    });
                    
                    // Update content state when editor changes
                    editorRef.current.onDidChangeModelContent(() => {
                        setContent(editorRef.current.getValue());
                    });
                });
                
                return () => {
                    if (editorRef.current) {
                        editorRef.current.dispose();
                    }
                };
            }, [containerRef, file, data]);
            
            const handleSave = () => {
                if (onSave && editorRef.current) {
                    onSave(editorRef.current.getValue());
                }
            };
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Text Editor: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs" onClick={handleSave}>Save</button>
                        </div>
                    </div>
                    <div 
                        ref={containerRef} 
                        className="monaco-editor"
                        style={{ height: 'calc(100% - 40px)' }}
                    ></div>
                </div>
            );
        };
        
        // Component: Cutscene Viewer
        const CutsceneViewer = ({ file, data }) => {
            const videoRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [videoMetadata, setVideoMetadata] = useState(null);
            
            useEffect(() => {
                if (!videoRef.current || !data) return;
                
                // Set up video player
                videoRef.current.src = data.url;
                
                videoRef.current.addEventListener('loadedmetadata', () => {
                    setDuration(videoRef.current.duration);
                    setVideoMetadata({
                        format: data.metadata?.format || 'Unknown',
                        width: videoRef.current.videoWidth,
                        height: videoRef.current.videoHeight,
                        duration: videoRef.current.duration
                    });
                });
                
                videoRef.current.addEventListener('timeupdate', () => {
                    setCurrentTime(videoRef.current.currentTime);
                });
                
                videoRef.current.addEventListener('play', () => {
                    setIsPlaying(true);
                });
                
                videoRef.current.addEventListener('pause', () => {
                    setIsPlaying(false);
                });
                
                videoRef.current.addEventListener('ended', () => {
                    setIsPlaying(false);
                });
                
                return () => {
                    if (videoRef.current) {
                        videoRef.current.pause();
                        videoRef.current.src = '';
                    }
                };
            }, [videoRef, data]);
            
            const togglePlay = () => {
                if (videoRef.current) {
                    if (isPlaying) {
                        videoRef.current.pause();
                    } else {
                        videoRef.current.play().catch(err => {
                            console.error('Error playing video:', err);
                            alert('Error playing video. This format may not be supported by your browser.');
                        });
                    }
                }
            };
            
            const handleSeek = (e) => {
                if (videoRef.current) {
                    const newTime = parseFloat(e.target.value);
                    videoRef.current.currentTime = newTime;
                    setCurrentTime(newTime);
                }
            };
            
            const formatTime = (timeInSeconds) => {
                if (!timeInSeconds) return '0:00';
                
                const minutes = Math.floor(timeInSeconds / 60);
                const seconds = Math.floor(timeInSeconds % 60);
                return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            };
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Cutscene Viewer: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs">Export Frame</button>
                            <button className="matrix-button m-2 text-xs">Save</button>
                        </div>
                    </div>
                    
                    <div className="p-4 flex flex-col items-center justify-center" style={{ height: 'calc(100% - 40px)', overflow: 'auto' }}>
                        <div 
                            style={{ 
                                width: '100%', 
                                maxWidth: '800px', 
                                backgroundColor: '#000', 
                                position: 'relative',
                                borderRadius: '5px',
                                overflow: 'hidden'
                            }}
                        >
                            <video
                                ref={videoRef}
                                style={{ 
                                    width: '100%',
                                    display: 'block'
                                }}
                                playsInline
                            />
                            
                            {!isPlaying && (
                                <div 
                                    style={{
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        backgroundColor: 'rgba(0,0,0,0.3)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        cursor: 'pointer'
                                    }}
                                    onClick={togglePlay}
                                >
                                    <div 
                                        style={{
                                            width: '60px',
                                            height: '60px',
                                            borderRadius: '50%',
                                            backgroundColor: 'rgba(0,255,0,0.2)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            border: '2px solid #00ff00'
                                        }}
                                    >
                                        <span style={{ fontSize: '24px', color: '#00ff00' }}>▶</span>
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        <div className="w-full max-w-[800px] mt-4">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm">{formatTime(currentTime)}</span>
                                <span className="text-sm">{formatTime(duration)}</span>
                            </div>
                            
                            <input
                                type="range"
                                min="0"
                                max={duration || 100}
                                value={currentTime}
                                onChange={handleSeek}
                                className="w-full"
                                style={{
                                    height: '4px',
                                    appearance: 'none',
                                    backgroundColor: '#001a00',
                                    outline: 'none',
                                    borderRadius: '2px',
                                    cursor: 'pointer'
                                }}
                            />
                            
                            <div className="flex items-center justify-center mt-4">
                                <button 
                                    className="matrix-button mx-2"
                                    onClick={() => {
                                        if (videoRef.current) {
                                            videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 10);
                                        }
                                    }}
                                >
                                    -10s
                                </button>
                                
                                <button 
                                    className="matrix-button mx-2"
                                    onClick={togglePlay}
                                >
                                    {isPlaying ? 'Pause' : 'Play'}
                                </button>
                                
                                <button 
                                    className="matrix-button mx-2"
                                    onClick={() => {
                                        if (videoRef.current) {
                                            videoRef.current.currentTime = Math.min(
                                                videoRef.current.duration,
                                                videoRef.current.currentTime + 10
                                            );
                                        }
                                    }}
                                >
                                    +10s
                                </button>
                            </div>
                        </div>
                        
                        {videoMetadata && (
                            <div className="w-full max-w-[800px] mt-8 p-4" style={{ backgroundColor: 'rgba(0, 255, 0, 0.1)', borderRadius: '5px' }}>
                                <h4 className="text-sm font-bold mb-2">Video Information</h4>
                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <p className="text-sm mb-1"><strong>Format:</strong> {videoMetadata.format}</p>
                                        <p className="text-sm mb-1"><strong>Duration:</strong> {formatTime(videoMetadata.duration)}</p>
                                    </div>
                                    <div>
                                        <p className="text-sm mb-1"><strong>Resolution:</strong> {videoMetadata.width}x{videoMetadata.height}</p>
                                        <p className="text-sm mb-1"><strong>File Size:</strong> {file.size} bytes</p>
                                    </div>
                                </div>
                                
                                <p className="text-sm mt-4 mb-2">
                                    <strong>Matrix Online Cutscene:</strong> This video file contains in-game cinematics from The Matrix Online.
                                </p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };
        
        // Component: Audio Editor
        const AudioEditor = ({ file, data }) => {
            const audioRef = useRef(null);
            const canvasRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [activeTab, setActiveTab] = useState('waveform');
            const [audioMetadata, setAudioMetadata] = useState(null);
            
            useEffect(() => {
                if (!audioRef.current || !canvasRef.current) return;
                
                // Set up audio visualization
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const canvas = canvasRef.current;
                const canvasCtx = canvas.getContext('2d');
                
                const source = audioContext.createMediaElementSource(audioRef.current);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                
                // Get audio metadata when loaded
                audioRef.current.onloadedmetadata = () => {
                    setAudioMetadata({
                        duration: audioRef.current.duration,
                        sampleRate: audioContext.sampleRate,
                        channels: 2, // Assuming stereo
                        format: file.name.split('.').pop().toUpperCase()
                    });
                };
                
                function draw() {
                    const WIDTH = canvas.width;
                    const HEIGHT = canvas.height;
                    
                    requestAnimationFrame(draw);
                    
                    analyser.getByteTimeDomainData(dataArray);
                    
                    canvasCtx.fillStyle = 'rgb(0, 26, 0)';
                    canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
                    
                    canvasCtx.lineWidth = 2;
                    canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
                    
                    canvasCtx.beginPath();
                    
                    const sliceWidth = WIDTH * 1.0 / bufferLength;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * HEIGHT / 2;
                        
                        if (i === 0) {
                            canvasCtx.moveTo(x, y);
                        } else {
                            canvasCtx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    canvasCtx.lineTo(canvas.width, canvas.height / 2);
                    canvasCtx.stroke();
                }
                
                draw();
                
                return () => {
                    if (audioContext.state !== 'closed') {
                        audioContext.close();
                    }
                };
            }, [audioRef, canvasRef, file]);
            
            const togglePlay = () => {
                if (audioRef.current) {
                    if (isPlaying) {
                        audioRef.current.pause();
                    } else {
                        audioRef.current.play();
                    }
                    setIsPlaying(!isPlaying);
                }
            };
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Audio Editor: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs">Export</button>
                            <button className="matrix-button m-2 text-xs">Save</button>
                        </div>
                    </div>
                    
                    {/* Tabs */}
                    <div className="border-b border-green-900">
                        <div className="flex">
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'waveform' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('waveform')}
                            >
                                Waveform
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'spectrum' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('spectrum')}
                            >
                                Spectrum
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'metadata' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('metadata')}
                            >
                                Metadata
                            </div>
                        </div>
                    </div>
                    
                    <div className="p-4" style={{ height: 'calc(100% - 80px)', overflowY: 'auto' }}>
                        {activeTab === 'waveform' && (
                            <div className="flex flex-col items-center justify-center">
                                <canvas 
                                    ref={canvasRef}
                                    width="600"
                                    height="200"
                                    style={{ 
                                        width: '100%', 
                                        maxWidth: '600px',
                                        border: '1px solid #00ff00' 
                                    }}
                                ></canvas>
                                
                                <div className="flex items-center justify-center mt-4 mb-2">
                                    <button 
                                        className="matrix-button m-2"
                                        onClick={togglePlay}
                                    >
                                        {isPlaying ? 'Pause' : 'Play'}
                                    </button>
                                </div>
                                
                                <audio 
                                    ref={audioRef}
                                    src={data ? data.url : ''}
                                    onEnded={() => setIsPlaying(false)}
                                    controls
                                    style={{ 
                                        width: '100%',
                                        maxWidth: '600px',
                                        marginTop: '20px',
                                        backgroundColor: '#001a00',
                                        borderRadius: '3px'
                                    }}
                                ></audio>
                            </div>
                        )}
                        
                        {activeTab === 'spectrum' && (
                            <div className="flex flex-col items-center justify-center">
                                <p className="mb-4 text-center">Frequency Spectrum Analysis</p>
                                <div
                                    style={{
                                        width: '100%',
                                        maxWidth: '600px',
                                        height: '200px',
                                        backgroundColor: '#001a00',
                                        border: '1px solid #00ff00',
                                        position: 'relative'
                                    }}
                                >
                                    {/* Simulated frequency bars */}
                                    {Array.from({ length: 32 }).map((_, i) => {
                                        const height = Math.random() * 70 + 10;
                                        return (
                                            <div
                                                key={i}
                                                style={{
                                                    position: 'absolute',
                                                    bottom: '0',
                                                    left: `${i * 3}%`,
                                                    width: '2%',
                                                    height: `${height}%`,
                                                    backgroundColor: '#00ff00',
                                                    opacity: '0.7'
                                                }}
                                            ></div>
                                        );
                                    })}
                                </div>
                                
                                <div className="mt-4 text-center text-sm">
                                    <p>Frequency (Hz)</p>
                                    <div className="flex justify-between w-full max-w-[600px] mt-2">
                                        <span>20</span>
                                        <span>100</span>
                                        <span>500</span>
                                        <span>1k</span>
                                        <span>5k</span>
                                        <span>10k</span>
                                        <span>20k</span>
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {activeTab === 'metadata' && (
                            <div className="w-full max-w-[600px] mx-auto">
                                <h4 className="text-sm font-bold mb-4">Audio File Information</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                    <tbody>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Filename</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {file.name}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Format</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {audioMetadata?.format || file.name.split('.').pop().toUpperCase()}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Duration</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {audioMetadata?.duration ? `${audioMetadata.duration.toFixed(2)} seconds` : 'Unknown'}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Sample Rate</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {audioMetadata?.sampleRate ? `${audioMetadata.sampleRate} Hz` : 'Unknown'}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Channels</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {audioMetadata?.channels || 'Unknown'}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>File Size</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {file.size} bytes
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                                
                                <h4 className="text-sm font-bold mt-6 mb-4">Matrix Online Context</h4>
                                <p className="text-sm mb-4">
                                    Audio files in Matrix Online are typically used for:
                                </p>
                                <ul className="text-sm list-disc pl-5">
                                    <li className="mb-2">Character dialog and voice lines</li>
                                    <li className="mb-2">Environmental sound effects</li>
                                    <li className="mb-2">User interface sounds</li>
                                    <li className="mb-2">Background music and ambient audio</li>
                                </ul>
                            </div>
                        )}
                    </div>
                </div>
            );
        };
        
        // Component: Cutscene Player
        const CutscenePlayer = ({ file, data }) => {
            const videoRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [videoMetadata, setVideoMetadata] = useState(null);
            
            useEffect(() => {
                if (!videoRef.current) return;
                
                const video = videoRef.current;
                
                // Ensure video is properly loaded
                if (data) {
                    // Use the URL from data, which for BIK files will be the proxy URL
                    const videoSrc = data.url || data.src;
                    if (videoSrc) {
                        video.src = videoSrc;
                        video.load();
                        console.log('Loading video:', videoSrc);
                    }
                }
                
                // Get video metadata when loaded
                video.onloadedmetadata = () => {
                    console.log('Video metadata loaded:', video.videoWidth, 'x', video.videoHeight);
                    setDuration(video.duration);
                    setVideoMetadata({
                        duration: video.duration,
                        width: video.videoWidth,
                        height: video.videoHeight,
                        format: file.name.split('.').pop().toUpperCase()
                    });
                };
                
                // Handle video errors (especially for BIK files)
                video.onerror = (e) => {
                    console.error('Video error:', e);
                    if (file.name.toLowerCase().endsWith('.bik')) {
                        // For BIK files, show a message
                        setVideoMetadata({
                            duration: 0,
                            width: 640,
                            height: 480,
                            format: 'BIK',
                            error: 'BIK files require conversion. Ensure: 1) BIK proxy server is running on port 8002, 2) FFmpeg is installed, 3) BIK files are accessible to the server'
                        });
                    }
                };
                
                // Update current time during playback
                video.ontimeupdate = () => {
                    setCurrentTime(video.currentTime);
                };
                
                // Handle playback end
                video.onended = () => {
                    setIsPlaying(false);
                };
                
                return () => {
                    // Clean up event listeners
                    video.onloadedmetadata = null;
                    video.ontimeupdate = null;
                    video.onended = null;
                };
            }, [videoRef, file, data]);
            
            const togglePlay = () => {
                if (videoRef.current) {
                    if (isPlaying) {
                        videoRef.current.pause();
                    } else {
                        videoRef.current.play();
                    }
                    setIsPlaying(!isPlaying);
                }
            };
            
            const handleSeek = (e) => {
                if (!videoRef.current || !duration) return;
                
                const seekPosition = parseFloat(e.target.value);
                videoRef.current.currentTime = seekPosition;
                setCurrentTime(seekPosition);
            };
            
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Cutscene Player: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs">Export</button>
                            <button className="matrix-button m-2 text-xs">Extract Frames</button>
                        </div>
                    </div>
                    
                    <div className="p-4 flex flex-col items-center" style={{ height: 'calc(100% - 40px)', overflowY: 'auto' }}>
                        <div className="relative w-full max-w-[800px]" style={{ backgroundColor: '#000', aspectRatio: '16/9' }}>
                            <video
                                ref={videoRef}
                                style={{ 
                                    width: '100%',
                                    height: '100%',
                                    objectFit: 'contain'
                                }}
                                onClick={togglePlay}
                                controls={false}
                            ></video>
                            
                            {!isPlaying && (
                                <div 
                                    className="absolute inset-0 flex items-center justify-center cursor-pointer"
                                    onClick={togglePlay}
                                >
                                    <div className="w-16 h-16 bg-green-800 bg-opacity-70 rounded-full flex items-center justify-center">
                                        <div className="w-0 h-0 border-t-8 border-b-8 border-l-16 border-transparent border-l-green-300 ml-2"></div>
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        <div className="w-full max-w-[800px] mt-4">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm">{formatTime(currentTime)}</span>
                                <span className="text-sm">{formatTime(duration)}</span>
                            </div>
                            
                            <input
                                type="range"
                                min="0"
                                max={duration || 100}
                                value={currentTime}
                                onChange={handleSeek}
                                className="w-full"
                                style={{
                                    height: '4px',
                                    appearance: 'none',
                                    backgroundColor: '#001a00',
                                    outline: 'none',
                                    borderRadius: '2px',
                                    cursor: 'pointer'
                                }}
                            />
                            
                            <div className="flex items-center justify-center mt-4">
                                <button 
                                    className="matrix-button mx-2"
                                    onClick={() => {
                                        if (videoRef.current) {
                                            videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 10);
                                        }
                                    }}
                                >
                                    -10s
                                </button>
                                
                                <button 
                                    className="matrix-button mx-2"
                                    onClick={togglePlay}
                                >
                                    {isPlaying ? 'Pause' : 'Play'}
                                </button>
                                
                                <button 
                                    className="matrix-button mx-2"
                                    onClick={() => {
                                        if (videoRef.current) {
                                            videoRef.current.currentTime = Math.min(
                                                videoRef.current.duration,
                                                videoRef.current.currentTime + 10
                                            );
                                        }
                                    }}
                                >
                                    +10s
                                </button>
                            </div>
                        </div>
                        
                        {videoMetadata && (
                            <div className="w-full max-w-[800px] mt-8 p-4" style={{ backgroundColor: 'rgba(0, 255, 0, 0.1)', borderRadius: '5px' }}>
                                <h4 className="text-sm font-bold mb-2">Video Information</h4>
                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <p className="text-sm mb-1"><strong>Format:</strong> {videoMetadata.format}</p>
                                        <p className="text-sm mb-1"><strong>Duration:</strong> {formatTime(videoMetadata.duration)}</p>
                                    </div>
                                    <div>
                                        <p className="text-sm mb-1"><strong>Resolution:</strong> {videoMetadata.width}x{videoMetadata.height}</p>
                                        <p className="text-sm mb-1"><strong>File Size:</strong> {file.size} bytes</p>
                                    </div>
                                </div>
                                
                                <p className="text-sm mt-4 mb-2">
                                    <strong>Matrix Online Cutscene:</strong> This video file contains in-game cinematics from The Matrix Online.
                                </p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };
        
        // Component: Archive Viewer
        const ArchiveViewer = ({ file, data, onFileExtracted }) => {
            const [selectedEntry, setSelectedEntry] = useState(null);
            const [extractionPath, setExtractionPath] = useState('./extracted');
            const [showExtractionDialog, setShowExtractionDialog] = useState(false);
            const [extractingFile, setExtractingFile] = useState(null);
            const [extractionProgress, setExtractionProgress] = useState(0);
            
            // Handle extraction of a single file
            const handleExtractFile = (entry, index) => {
                setSelectedEntry(index);
                setExtractingFile(entry);
                setShowExtractionDialog(true);
            };
            
            // Handle extraction of all files
            const handleExtractAll = () => {
                setExtractingFile(null); // Indicates we're extracting all files
                setShowExtractionDialog(true);
            };
            
            // Process file extraction
            const processExtraction = () => {
                setExtractionProgress(0);
                
                // Determine which files to extract
                const filesToExtract = extractingFile ? [extractingFile] : (data?.files || []);
                
                // Start extraction process
                let processed = 0;
                
                // Simulate extraction process
                const extractInterval = setInterval(() => {
                    processed++;
                    setExtractionProgress(Math.floor((processed / filesToExtract.length) * 100));
                    
                    // When finished
                    if (processed >= filesToExtract.length) {
                        clearInterval(extractInterval);
                        
                        // Create extracted file objects to add to the file system
                        const extractedFiles = filesToExtract.map(entry => {
                            // Create a File object from the array buffer
                            const blob = new Blob([entry.data], { type: getMimeType(entry.name) });
                            const file = new File([blob], entry.name, { 
                                type: getMimeType(entry.name), 
                                lastModified: new Date().getTime() 
                            });
                            
                            return {
                                path: `${extractionPath}/${entry.name}`,
                                file: file
                            };
                        });
                        
                        // Notify parent component about extracted files
                        if (onFileExtracted) {
                            onFileExtracted(extractedFiles);
                        }
                        
                        setShowExtractionDialog(false);
                        setExtractingFile(null);
                        
                        // Show success message
                        alert(`Successfully extracted ${filesToExtract.length} file(s) to ${extractionPath}`);
                    }
                }, 100);
            };
            
            // Helper function to get MIME type from filename
            const getMimeType = (filename) => {
                const ext = filename.split('.').pop().toLowerCase();
                const mimeTypes = {
                    'dtx': 'application/octet-stream',
                    'abc': 'application/octet-stream',
                    'dat': 'application/octet-stream',
                    'wav': 'audio/wav',
                    'mp3': 'audio/mpeg',
                    'ogg': 'audio/ogg',
                    'lua': 'text/plain',
                    'txt': 'text/plain',
                    'cs': 'text/plain',
                    'xml': 'text/xml',
                    'jpg': 'image/jpeg',
                    'png': 'image/png'
                };
                
                return mimeTypes[ext] || 'application/octet-stream';
            };
            
            // Preview selected file
            const previewFile = (entry, index) => {
                setSelectedEntry(index);
                
                const fileExt = '.' + entry.name.split('.').pop().toLowerCase();
                const fileType = getFileType(entry.name);
                
                if (FILE_TYPES.MODEL.extensions.includes(fileExt)) {
                    alert('Model preview not implemented in this demo');
                } else if (FILE_TYPES.TEXTURE.extensions.includes(fileExt)) {
                    alert('Texture preview not implemented in this demo');
                } else if (FILE_TYPES.SOUND.extensions.includes(fileExt)) {
                    // Create audio URL and play
                    const blob = new Blob([entry.data], { type: getMimeType(entry.name) });
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    audio.play();
                } else if (FILE_TYPES.SCRIPT.extensions.includes(fileExt) || 
                          FILE_TYPES.MESSAGE.extensions.includes(fileExt)) {
                    // Show text preview
                    const decoder = new TextDecoder('utf-8');
                    const text = decoder.decode(entry.data);
                    alert(`Preview of ${entry.name}:\n\n${text.substring(0, 500)}${text.length > 500 ? '...' : ''}`);
                } else {
                    alert(`Preview not available for ${entry.name}`);
                }
            };
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Archive Viewer: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs" onClick={handleExtractAll}>Extract All</button>
                        </div>
                    </div>
                    <div className="p-4 overflow-auto" style={{ height: 'calc(100% - 40px)' }}>
                        {data && data.metadata && (
                            <div className="mb-4 p-2" style={{ backgroundColor: 'rgba(0, 255, 0, 0.1)', borderRadius: '5px' }}>
                                <p className="text-sm"><strong>Format:</strong> {data.metadata.format}</p>
                                <p className="text-sm"><strong>Files:</strong> {data.metadata.fileCount}</p>
                                <p className="text-sm"><strong>Size:</strong> {data.metadata.totalSize} bytes</p>
                            </div>
                        )}
                        
                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                                <tr>
                                    <th style={{ textAlign: 'left', padding: '8px', borderBottom: '1px solid #00ff00' }}>Filename</th>
                                    <th style={{ textAlign: 'right', padding: '8px', borderBottom: '1px solid #00ff00' }}>Size</th>
                                    <th style={{ textAlign: 'center', padding: '8px', borderBottom: '1px solid #00ff00' }}>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {data && data.files && data.files.map((entry, index) => (
                                    <tr 
                                        key={index}
                                        style={{ 
                                            borderBottom: '1px solid rgba(0, 255, 0, 0.2)',
                                            backgroundColor: selectedEntry === index ? 'rgba(0, 255, 0, 0.1)' : 'transparent'
                                        }}
                                        onClick={() => setSelectedEntry(index)}
                                    >
                                        <td style={{ padding: '8px' }}>
                                            {getFileType(entry.name).icon} {entry.name}
                                        </td>
                                        <td style={{ padding: '8px', textAlign: 'right' }}>
                                            {entry.size} bytes
                                        </td>
                                        <td style={{ padding: '8px', textAlign: 'center' }}>
                                            <button 
                                                className="matrix-button text-xs m-1"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    previewFile(entry, index);
                                                }}
                                            >
                                                Preview
                                            </button>
                                            <button 
                                                className="matrix-button text-xs m-1"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    handleExtractFile(entry, index);
                                                }}
                                            >
                                                Extract
                                            </button>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    
                    {/* Extraction Dialog */}
                    {showExtractionDialog && (
                        <div 
                            style={{
                                position: 'fixed',
                                top: 0,
                                left: 0,
                                right: 0,
                                bottom: 0,
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                zIndex: 1000
                            }}
                        >
                            <div 
                                style={{
                                    backgroundColor: '#001a00',
                                    border: '1px solid #00ff00',
                                    padding: '20px',
                                    borderRadius: '5px',
                                    width: '400px'
                                }}
                            >
                                <h3 className="matrix-title text-sm mb-4">
                                    {extractingFile 
                                        ? `Extract ${extractingFile.name}` 
                                        : `Extract All Files (${data?.files?.length || 0} files)`}
                                </h3>
                                
                                <div className="mb-4">
                                    <label className="text-sm block mb-2">Extraction Path:</label>
                                    <input 
                                        type="text" 
                                        value={extractionPath}
                                        onChange={(e) => setExtractionPath(e.target.value)}
                                        style={{
                                            backgroundColor: '#000800',
                                            color: '#00ff00',
                                            border: '1px solid #00ff00',
                                            padding: '8px',
                                            width: '100%'
                                        }}
                                    />
                                </div>
                                
                                {extractionProgress > 0 && (
                                    <div className="mb-4">
                                        <div style={{ 
                                            height: '20px', 
                                            backgroundColor: '#000800',
                                            border: '1px solid #00ff00',
                                            borderRadius: '3px',
                                            overflow: 'hidden'
                                        }}>
                                            <div style={{
                                                height: '100%',
                                                width: `${extractionProgress}%`,
                                                backgroundColor: '#00ff00',
                                                transition: 'width 0.3s'
                                            }}></div>
                                        </div>
                                        <p className="text-sm mt-2 text-center">{extractionProgress}%</p>
                                    </div>
                                )}
                                
                                <div className="flex justify-between">
                                    <button 
                                        className="matrix-button text-xs"
                                        onClick={() => setShowExtractionDialog(false)}
                                    >
                                        Cancel
                                    </button>
                                    <button 
                                        className="matrix-button text-xs"
                                        onClick={processExtraction}
                                    >
                                        Extract
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        
        // Component: Assembly Viewer (for DLL/EXE files)
        const AssemblyViewer = ({ file, data }) => {
            const [activeTab, setActiveTab] = useState('info');
            const [isDecompiling, setIsDecompiling] = useState(false);
            const [decompilerOutput, setDecompilerOutput] = useState(null);
            const monacoRef = useRef(null);
            
            if (!data) {
                return (
                    <div className="editor-container p-4 flex items-center justify-center">
                        <p>Loading assembly information...</p>
                    </div>
                );
            }
            
            // Handle decompile action
            const handleDecompile = () => {
                setIsDecompiling(true);
                
                // Simulate decompilation process (would use a real decompiler in production)
                setTimeout(() => {
                    // Generate pseudo-code based on the sections and imports data
                    let pseudoCode = '';
                    
                    // Add header
                    pseudoCode += `// Decompiled from ${file.name}\n`;
                    pseudoCode += `// ${data.isDll ? 'Dynamic Link Library' : 'Executable'}\n`;
                    pseudoCode += `// Architecture: ${data.machine === 0x014c ? 'x86' : data.machine === 0x8664 ? 'x64' : 'Unknown'}\n`;
                    pseudoCode += `// Timestamp: ${data.timestamp}\n\n`;
                    
                    // Add imports
                    pseudoCode += '// Imported libraries and functions\n';
                    data.imports.forEach(lib => {
                        pseudoCode += `#include <${lib.dll.replace('.dll', '')}>\n`;
                    });
                    pseudoCode += '\n';
                    
                    // Add exports
                    if (data.exports.length > 0) {
                        pseudoCode += '// Exported functions\n';
                        data.exports.forEach(exp => {
                            // Generate sample function code
                            pseudoCode += `\n/* Function: ${exp.name} (Ordinal: ${exp.ordinal}) */\n`;
                            pseudoCode += `DWORD WINAPI ${exp.name}(LPVOID lpParam) {\n`;
                            
                            // Add sample implementation
                            if (exp.name.toLowerCase().includes('init') || exp.name.toLowerCase().includes('initialize')) {
                                pseudoCode += '    // Initialize component\n';
                                pseudoCode += '    if (!InitializeInternalStructures()) {\n';
                                pseudoCode += '        return ERROR_INITIALIZATION_FAILED;\n';
                                pseudoCode += '    }\n';
                                pseudoCode += '    \n';
                                pseudoCode += '    // Register with system\n';
                                pseudoCode += '    HANDLE hSystem = RegisterSystemCallback(OnSystemEvent);\n';
                                pseudoCode += '    if (hSystem == INVALID_HANDLE_VALUE) {\n';
                                pseudoCode += '        return GetLastError();\n';
                                pseudoCode += '    }\n';
                                pseudoCode += '    \n';
                                pseudoCode += '    g_IsInitialized = TRUE;\n';
                                pseudoCode += '    return ERROR_SUCCESS;\n';
                            } else if (exp.name.toLowerCase().includes('shutdown') || exp.name.toLowerCase().includes('close')) {
                                pseudoCode += '    // Clean up resources\n';
                                pseudoCode += '    if (g_IsInitialized) {\n';
                                pseudoCode += '        UnregisterSystemCallback(g_hSystem);\n';
                                pseudoCode += '        FreeInternalStructures();\n';
                                pseudoCode += '        g_IsInitialized = FALSE;\n';
                                pseudoCode += '    }\n';
                                pseudoCode += '    \n';
                                pseudoCode += '    return ERROR_SUCCESS;\n';
                            } else if (exp.name.toLowerCase().includes('process')) {
                                pseudoCode += '    // Process incoming data\n';
                                pseudoCode += '    PDATA_STRUCTURE pData = (PDATA_STRUCTURE)lpParam;\n';
                                pseudoCode += '    if (!pData || pData->dwSize < sizeof(DATA_STRUCTURE)) {\n';
                                pseudoCode += '        return ERROR_INVALID_PARAMETER;\n';
                                pseudoCode += '    }\n';
                                pseudoCode += '    \n';
                                pseudoCode += '    // Process data\n';
                                pseudoCode += '    switch(pData->dwType) {\n';
                                pseudoCode += '        case DATA_TYPE_COMMAND:\n';
                                pseudoCode += '            return ProcessCommand(&pData->Command);\n';
                                pseudoCode += '        case DATA_TYPE_QUERY:\n';
                                pseudoCode += '            return ProcessQuery(&pData->Query);\n';
                                pseudoCode += '        default:\n';
                                pseudoCode += '            return ERROR_INVALID_PARAMETER;\n';
                                pseudoCode += '    }\n';
                            } else {
                                pseudoCode += '    // Implementation not available\n';
                                pseudoCode += '    return ERROR_SUCCESS;\n';
                            }
                            
                            pseudoCode += '}\n';
                        });
                    }
                    
                    // If no exports, add a main function for executables
                    if (data.exports.length === 0 && !data.isDll) {
                        pseudoCode += '\n/* Main entry point */\n';
                        pseudoCode += 'int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\n';
                        pseudoCode += '    // Initialize application\n';
                        pseudoCode += '    if (!InitializeApplication(hInstance)) {\n';
                        pseudoCode += '        MessageBox(NULL, "Failed to initialize application", "Error", MB_OK | MB_ICONERROR);\n';
                        pseudoCode += '        return 1;\n';
                        pseudoCode += '    }\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    // Create main window\n';
                        pseudoCode += '    HWND hWnd = CreateMainWindow(hInstance);\n';
                        pseudoCode += '    if (!hWnd) {\n';
                        pseudoCode += '        MessageBox(NULL, "Failed to create main window", "Error", MB_OK | MB_ICONERROR);\n';
                        pseudoCode += '        return 1;\n';
                        pseudoCode += '    }\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    // Show window\n';
                        pseudoCode += '    ShowWindow(hWnd, nCmdShow);\n';
                        pseudoCode += '    UpdateWindow(hWnd);\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    // Message loop\n';
                        pseudoCode += '    MSG msg;\n';
                        pseudoCode += '    while (GetMessage(&msg, NULL, 0, 0)) {\n';
                        pseudoCode += '        TranslateMessage(&msg);\n';
                        pseudoCode += '        DispatchMessage(&msg);\n';
                        pseudoCode += '    }\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    return (int)msg.wParam;\n';
                        pseudoCode += '}\n';
                    }
                    
                    // Add a section for Matrix Online specific code
                    if (file.name.toLowerCase().includes('matrix') || 
                        file.name.toLowerCase().includes('mxo') || 
                        file.name.toLowerCase().includes('lithtech')) {
                        
                        pseudoCode += '\n/* Matrix Online specific functions */\n';
                        pseudoCode += '\n// Lithtech engine interface\n';
                        pseudoCode += 'BOOL InitializeLithtech(HMODULE hModule) {\n';
                        pseudoCode += '    // Initialize Lithtech engine\n';
                        pseudoCode += '    g_pLTClient = (ILTClient*)GetProcAddress(hModule, "LTClientCreate");\n';
                        pseudoCode += '    if (!g_pLTClient) {\n';
                        pseudoCode += '        return FALSE;\n';
                        pseudoCode += '    }\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    // Initialize render system\n';
                        pseudoCode += '    RENDER_INIT_PARAMS params;\n';
                        pseudoCode += '    memset(&params, 0, sizeof(params));\n';
                        pseudoCode += '    params.m_Width = 800;\n';
                        pseudoCode += '    params.m_Height = 600;\n';
                        pseudoCode += '    params.m_BPP = 32;\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    if (g_pLTClient->InitRender(&params) != LT_OK) {\n';
                        pseudoCode += '        return FALSE;\n';
                        pseudoCode += '    }\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    return TRUE;\n';
                        pseudoCode += '}\n';
                        
                        pseudoCode += '\n// Matrix Online character creation\n';
                        pseudoCode += 'HCHARACTER CreateMatrixCharacter(const char* pszModelFile) {\n';
                        pseudoCode += '    CLIENT_OBJECT_CREATE_STRUCT createStruct;\n';
                        pseudoCode += '    memset(&createStruct, 0, sizeof(createStruct));\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    // Set up character properties\n';
                        pseudoCode += '    strcpy(createStruct.m_Filename, pszModelFile);\n';
                        pseudoCode += '    createStruct.m_ObjectType = OT_MODEL;\n';
                        pseudoCode += '    createStruct.m_Flags = FLAG_VISIBLE;\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    // Create the character\n';
                        pseudoCode += '    HOBJECT hObject;\n';
                        pseudoCode += '    if (g_pLTClient->CreateObject(&createStruct, &hObject) != LT_OK) {\n';
                        pseudoCode += '        return NULL;\n';
                        pseudoCode += '    }\n';
                        pseudoCode += '    \n';
                        pseudoCode += '    return (HCHARACTER)hObject;\n';
                        pseudoCode += '}\n';
                    }
                    
                    // Set the decompiled output
                    setDecompilerOutput(pseudoCode);
                    
                    // Switch to decompile tab
                    setActiveTab('decompile');
                    setIsDecompiling(false);
                }, 2000);
            };
            
            // Initialize Monaco editor for decompiled code
            const initMonacoEditor = (container) => {
                if (!container || !decompilerOutput) return;
                
                monacoRef.current = container;
                
                require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs' }});
                require(['vs/editor/editor.main'], () => {
                    if (container.innerHTML !== '') {
                        // Editor already initialized
                        return;
                    }
                    
                    // Create editor
                    const editor = monaco.editor.create(container, {
                        value: decompilerOutput,
                        language: 'cpp',
                        theme: 'vs-dark',
                        minimap: { enabled: true },
                        readOnly: false,
                        automaticLayout: true,
                        scrollBeyondLastLine: false,
                        fontSize: 14
                    });
                });
            };
            
            return (
                <div className="editor-container">
                    <div className="p-2 flex justify-between items-center">
                        <h3 className="matrix-title text-sm">Assembly Viewer: {file.name}</h3>
                        <div>
                            <button className="matrix-button m-2 text-xs">Export</button>
                            <button 
                                className="matrix-button m-2 text-xs" 
                                onClick={handleDecompile}
                                disabled={isDecompiling}
                            >
                                {isDecompiling ? 'Decompiling...' : 'Decompile'}
                            </button>
                        </div>
                    </div>
                    
                    <div className="border-b border-green-900">
                        <div className="flex">
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'info' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('info')}
                            >
                                Information
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'sections' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('sections')}
                            >
                                Sections
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'imports' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('imports')}
                            >
                                Imports
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'exports' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => setActiveTab('exports')}
                            >
                                Exports
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeTab === 'decompile' ? 'bg-green-900 text-green-100' : ''}`}
                                onClick={() => {
                                    if (decompilerOutput) {
                                        setActiveTab('decompile');
                                    } else {
                                        handleDecompile();
                                    }
                                }}
                            >
                                Decompiled Code
                            </div>
                        </div>
                    </div>
                    
                    <div className="p-4 overflow-auto" style={{ height: 'calc(100% - 80px)' }}>
                        {activeTab === 'info' && (
                            <div>
                                <h4 className="text-sm font-bold mb-2">Assembly Information</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                    <tbody>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Type</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {data.isDll ? 'Dynamic Link Library (DLL)' : 'Executable (EXE)'}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Machine</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {data.machine === 0x014c ? 'x86 (32-bit)' : 
                                                 data.machine === 0x8664 ? 'x64 (64-bit)' : 
                                                 `Unknown (0x${data.machine.toString(16)})`}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Timestamp</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {data.timestamp}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Managed Code</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {data.metadata.isManagedCode ? 'Yes (.NET)' : 'No (Native)'}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Sections</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {data.sections.length}
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Imports</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {data.imports.reduce((sum, lib) => sum + lib.functions.length, 0)} functions from {data.imports.length} libraries
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>Exports</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {data.exports.length} functions
                                            </td>
                                        </tr>
                                        <tr>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>File Size</td>
                                            <td style={{ padding: '8px', borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                {file.size} bytes
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                                
                                <div className="mt-4 p-2" style={{ backgroundColor: 'rgba(0, 255, 0, 0.1)', borderRadius: '5px' }}>
                                    <h4 className="text-sm font-bold mb-2">References</h4>
                                    <p className="text-sm">This assembly references the following libraries:</p>
                                    <ul className="text-sm mt-2">
                                        {data.imports.map((lib, index) => (
                                            <li key={index} className="ml-4">{lib.dll}</li>
                                        ))}
                                    </ul>
                                </div>
                            </div>
                        )}
                        
                        {activeTab === 'sections' && (
                            <div>
                                <h4 className="text-sm font-bold mb-2">PE Sections</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                    <thead>
                                        <tr>
                                            <th style={{ textAlign: 'left', padding: '8px', borderBottom: '1px solid #00ff00' }}>Name</th>
                                            <th style={{ textAlign: 'right', padding: '8px', borderBottom: '1px solid #00ff00' }}>Virtual Size</th>
                                            <th style={{ textAlign: 'right', padding: '8px', borderBottom: '1px solid #00ff00' }}>Virtual Address</th>
                                            <th style={{ textAlign: 'right', padding: '8px', borderBottom: '1px solid #00ff00' }}>Raw Size</th>
                                            <th style={{ textAlign: 'right', padding: '8px', borderBottom: '1px solid #00ff00' }}>Raw Offset</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {data.sections.map((section, index) => (
                                            <tr key={index} style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                <td style={{ padding: '8px' }}>{section.name}</td>
                                                <td style={{ padding: '8px', textAlign: 'right' }}>{section.virtualSize} bytes</td>
                                                <td style={{ padding: '8px', textAlign: 'right' }}>0x{section.virtualAddress.toString(16).toUpperCase()}</td>
                                                <td style={{ padding: '8px', textAlign: 'right' }}>{section.rawDataSize} bytes</td>
                                                <td style={{ padding: '8px', textAlign: 'right' }}>0x{section.rawDataOffset.toString(16).toUpperCase()}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                        
                        {activeTab === 'imports' && (
                            <div>
                                <h4 className="text-sm font-bold mb-2">Imported Functions</h4>
                                {data.imports.map((lib, libIndex) => (
                                    <div key={libIndex} className="mb-4">
                                        <h5 className="text-sm font-bold p-2" style={{ backgroundColor: 'rgba(0, 255, 0, 0.1)' }}>
                                            {lib.dll}
                                        </h5>
                                        <ul style={{ listStyle: 'none', padding: 0 }}>
                                            {lib.functions.map((func, funcIndex) => (
                                                <li key={funcIndex} style={{ padding: '4px 8px', borderBottom: '1px solid rgba(0, 255, 0, 0.1)' }}>
                                                    {func}
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                ))}
                            </div>
                        )}
                        
                        {activeTab === 'exports' && (
                            <div>
                                <h4 className="text-sm font-bold mb-2">Exported Functions</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                    <thead>
                                        <tr>
                                            <th style={{ textAlign: 'left', padding: '8px', borderBottom: '1px solid #00ff00' }}>Ordinal</th>
                                            <th style={{ textAlign: 'left', padding: '8px', borderBottom: '1px solid #00ff00' }}>Name</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {data.exports.map((exp, index) => (
                                            <tr key={index} style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.2)' }}>
                                                <td style={{ padding: '8px' }}>{exp.ordinal}</td>
                                                <td style={{ padding: '8px' }}>{exp.name}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                        
                        {activeTab === 'decompile' && (
                            <div>
                                {isDecompiling ? (
                                    <div className="flex flex-col items-center justify-center h-full">
                                        <div className="text-center">
                                            <div className="inline-block w-8 h-8 border-t-2 border-r-2 border-green-500 rounded-full animate-spin"></div>
                                            <p className="mt-4">Decompiling assembly code...</p>
                                            <p className="text-xs mt-2">This may take a few moments</p>
                                        </div>
                                    </div>
                                ) : decompilerOutput ? (
                                    <div style={{ height: '500px', minHeight: '500px' }} ref={initMonacoEditor}></div>
                                ) : (
                                    <div className="flex flex-col items-center justify-center h-full">
                                        <p>Click the "Decompile" button to generate decompiled code.</p>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };
        
        // Component: File Preview
        const FilePreview = ({ file, data }) => {
            if (!file) {
                return (
                    <div className="preview-container p-4">
                        <h3 className="matrix-title text-sm">Preview</h3>
                        <div className="p-4 text-sm text-center">
                            Select a file to preview
                        </div>
                    </div>
                );
            }
            
            const fileType = getFileType(file.name);
            
            // Determine if we have a thumbnail to display
            const hasThumbnail = data && data.thumbnail;
            
            return (
                <div className="preview-container">
                    <div className="p-2">
                        <h3 className="matrix-title text-sm">Preview: {file.name}</h3>
                    </div>
                    <div className="p-4">
                        {/* Display thumbnail if available */}
                        {hasThumbnail && (
                            <div className="flex justify-center mb-4">
                                <div 
                                    className="thumbnail-preview"
                                    style={{
                                        width: '128px',
                                        height: '128px',
                                        border: '1px solid var(--matrix-green, #00ff00)',
                                        overflow: 'hidden',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center'
                                    }}
                                >
                                    <img 
                                        src={data.thumbnail} 
                                        alt={`Thumbnail for ${file.name}`}
                                        style={{ maxWidth: '100%', maxHeight: '100%' }}
                                    />
                                </div>
                            </div>
                        )}
                        
                        <div className="p-2 border rounded" style={{ borderColor: 'rgba(0, 255, 0, 0.3)' }}>
                            <h4 style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.3)', paddingBottom: '8px' }}>
                                {fileType.name} File
                            </h4>
                            <p className="text-sm">{fileType.description}</p>
                            
                            {/* Render specific content based on file type */}
                            {data && data.type === 'model' && (
                                <div className="mt-4">
                                    <h4 style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.3)', paddingBottom: '8px' }}>
                                        Model Information
                                    </h4>
                                    <ul style={{ listStyle: 'none', padding: 0 }}>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Vertices:</strong> {data.vertices ? data.vertices.length / 3 : 0}
                                        </li>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Triangles:</strong> {data.indices ? data.indices.length / 3 : 0}
                                        </li>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Has UVs:</strong> {data.uvs && data.uvs.length > 0 ? 'Yes' : 'No'}
                                        </li>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Has Normals:</strong> {data.normals && data.normals.length > 0 ? 'Yes' : 'No'}
                                        </li>
                                    </ul>
                                </div>
                            )}
                            
                            {data && data.type === 'texture' && (
                                <div className="mt-4">
                                    <h4 style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.3)', paddingBottom: '8px' }}>
                                        Texture Information
                                    </h4>
                                    <ul style={{ listStyle: 'none', padding: 0 }}>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Dimensions:</strong> {data.width}x{data.height}
                                        </li>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Format:</strong> {data.format || 'Unknown'}
                                        </li>
                                    </ul>
                                </div>
                            )}
                            
                            {data && data.type === 'cutscene' && (
                                <div className="mt-4">
                                    <h4 style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.3)', paddingBottom: '8px' }}>
                                        Video Information
                                    </h4>
                                    <ul style={{ listStyle: 'none', padding: 0 }}>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Resolution:</strong> {data.width}x{data.height}
                                        </li>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Duration:</strong> {Math.floor(data.duration / 60)}:{Math.floor(data.duration % 60).toString().padStart(2, '0')}
                                        </li>
                                        <li className="text-sm" style={{ padding: '4px 0' }}>
                                            <strong>Format:</strong> {data.format || 'Unknown'}
                                        </li>
                                    </ul>
                                </div>
                            )}
                            
                            {data && data.metadata && (
                                <div className="mt-4">
                                    <h4 style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.3)', paddingBottom: '8px' }}>
                                        Metadata
                                    </h4>
                                    <ul style={{ listStyle: 'none', padding: 0 }}>
                                        {Object.entries(data.metadata).map(([key, value]) => (
                                            <li key={key} className="text-sm" style={{ padding: '4px 0' }}>
                                                <strong>{key}:</strong> {JSON.stringify(value)}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            )}
                            
                            <div className="mt-4">
                                <h4 style={{ borderBottom: '1px solid rgba(0, 255, 0, 0.3)', paddingBottom: '8px' }}>
                                    File Information
                                </h4>
                                <ul style={{ listStyle: 'none', padding: 0 }}>
                                    <li className="text-sm" style={{ padding: '4px 0' }}>
                                        <strong>Size:</strong> {file.size} bytes
                                    </li>
                                    <li className="text-sm" style={{ padding: '4px 0' }}>
                                        <strong>Last Modified:</strong> {new Date(file.lastModified).toLocaleString()}
                                    </li>
                                    <li className="text-sm" style={{ padding: '4px 0' }}>
                                        <strong>Type:</strong> {file.type || 'application/octet-stream'}
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        // Component: GameObjects Log Analyzer
        const GameObjectsAnalyzer = ({ allFiles }) => {
            const [selectedLog, setSelectedLog] = useState(null);
            const [analyzedData, setAnalyzedData] = useState(null);
            const [activeTab, setActiveTab] = useState('overview');
            const [searchTerm, setSearchTerm] = useState('');
            const [filterType, setFilterType] = useState('all');
            const [sortBy, setSortBy] = useState('name');
            const [sortOrder, setSortOrder] = useState('asc');
            const [categoryFilter, setCategoryFilter] = useState('all');
            const [isAnalyzing, setIsAnalyzing] = useState(false);
            
            // Categorize log files based on their name/path
            const categorizeLogFile = React.useCallback((path) => {
                const fileName = path.toLowerCase();
                
                // Combat-related files
                if (fileName.includes('combat') || fileName.includes('interlock') || 
                    fileName.includes('damage') || fileName.includes('attack') ||
                    fileName.includes('defense') || fileName.includes('accuracy') ||
                    fileName.includes('pvp') || fileName.includes('duel') ||
                    fileName.includes('ability') || fileName.includes('skill')) return 'combat';
                
                // GameObject and NPC files
                if (fileName.includes('gameobject') || fileName.includes('object') ||
                    fileName.includes('spawn') || fileName.includes('npc')) return 'gameobject';
                
                // Animation and effects
                if (fileName.includes('animation') || fileName.includes('anim') ||
                    fileName.includes('effect') || fileName.includes('fx')) return 'animation';
                
                // Network and protocol
                if (fileName.includes('network') || fileName.includes('packet') ||
                    fileName.includes('protocol') || fileName.includes('rpc')) return 'network';
                
                // Mission and quest files
                if (fileName.includes('mission') || fileName.includes('quest')) return 'mission';
                
                // Server files
                if (fileName.includes('server')) return 'server';
                
                // Client files
                if (fileName.includes('client')) return 'client';
                
                // Authentication
                if (fileName.includes('auth')) return 'auth';
                
                // Debug and error logs
                if (fileName.includes('debug')) return 'debug';
                if (fileName.includes('error')) return 'error';
                
                // Config files
                if (path.endsWith('.xml') || path.endsWith('.cfg') || 
                    path.endsWith('.ini') || path.endsWith('.json')) return 'config';
                
                return 'general';
            }, []);
            
            // Generate tags for files based on content patterns
            const generateFileTags = React.useCallback((path) => {
                const tags = [];
                const fileName = path.toLowerCase();
                
                // Add tags based on file name patterns
                if (fileName.includes('matrix')) tags.push('matrix');
                if (fileName.includes('mxo')) tags.push('mxo');
                if (fileName.includes('world')) tags.push('world');
                if (fileName.includes('chat')) tags.push('chat');
                if (fileName.includes('trade')) tags.push('trade');
                if (fileName.includes('mission')) tags.push('mission');
                if (fileName.includes('combat')) tags.push('combat');
                if (fileName.includes('interlock')) tags.push('interlock');
                if (fileName.includes('rpc')) tags.push('rpc');
                if (fileName.includes('protocol')) tags.push('protocol');
                if (fileName.includes('packet')) tags.push('packet');
                if (fileName.includes('socket')) tags.push('socket');
                if (fileName.includes('connection')) tags.push('connection');
                
                // Add date tags if found in filename
                const dateMatch = fileName.match(/\d{4}[-_]\d{2}[-_]\d{2}/);
                if (dateMatch) tags.push('dated');
                
                return tags;
            }, []);
            
            // Get log files from already loaded files
            const logFiles = React.useMemo(() => {
                if (!allFiles) return [];
                
                return Object.entries(allFiles)
                    .filter(([path, fileInfo]) => {
                        const ext = '.' + path.split('.').pop().toLowerCase();
                        const fileName = path.toLowerCase();
                        
                        // Include various combat and game-related file types
                        return FILE_TYPES.LOG.extensions.includes(ext) || 
                               fileName.includes('log') ||
                               fileName.includes('debug') ||
                               fileName.includes('server') ||
                               fileName.includes('client') ||
                               fileName.includes('combat') ||
                               fileName.includes('interlock') ||
                               fileName.includes('damage') ||
                               fileName.includes('ability') ||
                               fileName.includes('skill') ||
                               fileName.includes('attack') ||
                               fileName.includes('defense') ||
                               fileName.includes('accuracy') ||
                               fileName.includes('pvp') ||
                               fileName.includes('duel') ||
                               fileName.includes('mission') ||
                               fileName.includes('gameobject') ||
                               fileName.includes('rpc') ||
                               fileName.includes('packet') ||
                               fileName.includes('protocol') ||
                               fileName.includes('spawn') ||
                               fileName.includes('npc') ||
                               fileName.includes('animation') ||
                               fileName.includes('effect') ||
                               fileName.includes('trace') ||
                               // Also include XML files that might contain combat data
                               ext === '.xml' ||
                               ext === '.json' ||
                               ext === '.csv' ||
                               ext === '.dat' ||
                               ext === '.cfg' ||
                               ext === '.ini';
                    })
                    .map(([path, fileInfo]) => ({
                        path,
                        file: fileInfo.file,
                        name: path.split('/').pop(),
                        size: fileInfo.file.size,
                        category: categorizeLogFile(path),
                        tags: generateFileTags(path)
                    }));
            }, [allFiles, categorizeLogFile, generateFileTags]);
            
            // Log analysis patterns based on the Matrix Online technical documentation
            const analyzeLogFile = async (file) => {
                try {
                    const text = await file.text();
                    const fileName = file.name.toLowerCase();
                    
                    // Initialize analysis structure
                    const analysis = {
                        gameObjects: [],
                        combatMessages: [],
                        rpcCalls: [],
                        packetData: [],
                        animationIds: [],
                        statistics: {
                            totalLines: 0,
                            gameObjectCount: 0,
                            combatEventCount: 0,
                            rpcCallCount: 0,
                            packetCount: 0,
                            fileType: fileName.endsWith('.xml') ? 'XML' : 
                                     fileName.endsWith('.json') ? 'JSON' : 
                                     fileName.endsWith('.csv') ? 'CSV' : 'TEXT'
                        }
                    };
                    
                    // Handle different file types
                    if (fileName.endsWith('.xml')) {
                        // Parse XML files for combat data
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, "text/xml");
                        
                        // Look for combat-related XML elements
                        const combatElements = xmlDoc.querySelectorAll('combat, ability, skill, attack, damage, defense, interlock');
                        combatElements.forEach(elem => {
                            analysis.combatMessages.push({
                                line: 0,
                                content: elem.outerHTML,
                                type: elem.tagName.toLowerCase(),
                                timestamp: elem.getAttribute('timestamp') || null,
                                attributes: Array.from(elem.attributes).reduce((acc, attr) => {
                                    acc[attr.name] = attr.value;
                                    return acc;
                                }, {})
                            });
                            analysis.statistics.combatEventCount++;
                        });
                        
                        // Look for GameObject elements
                        const gameObjectElements = xmlDoc.querySelectorAll('gameobject, object, entity, npc, spawn');
                        gameObjectElements.forEach(elem => {
                            analysis.gameObjects.push({
                                line: 0,
                                content: elem.outerHTML,
                                objectId: elem.getAttribute('id') || elem.getAttribute('objectId') || 'unknown',
                                timestamp: elem.getAttribute('timestamp') || null
                            });
                            analysis.statistics.gameObjectCount++;
                        });
                        
                        analysis.statistics.totalLines = combatElements.length + gameObjectElements.length;
                        
                    } else if (fileName.endsWith('.json')) {
                        // Parse JSON files for combat data
                        try {
                            const jsonData = JSON.parse(text);
                            
                            // Recursive function to find combat-related data
                            const findCombatData = (obj, path = '') => {
                                if (Array.isArray(obj)) {
                                    obj.forEach((item, index) => findCombatData(item, `${path}[${index}]`));
                                } else if (typeof obj === 'object' && obj !== null) {
                                    Object.keys(obj).forEach(key => {
                                        const keyLower = key.toLowerCase();
                                        if (keyLower.includes('combat') || keyLower.includes('damage') || 
                                            keyLower.includes('attack') || keyLower.includes('defense') ||
                                            keyLower.includes('ability') || keyLower.includes('skill')) {
                                            analysis.combatMessages.push({
                                                line: 0,
                                                content: JSON.stringify({[key]: obj[key]}),
                                                type: keyLower,
                                                timestamp: obj.timestamp || null,
                                                path: `${path}.${key}`
                                            });
                                            analysis.statistics.combatEventCount++;
                                        }
                                        if (keyLower.includes('gameobject') || keyLower.includes('object') ||
                                            keyLower.includes('npc') || keyLower.includes('spawn')) {
                                            analysis.gameObjects.push({
                                                line: 0,
                                                content: JSON.stringify({[key]: obj[key]}),
                                                objectId: obj.id || obj.objectId || 'unknown',
                                                timestamp: obj.timestamp || null
                                            });
                                            analysis.statistics.gameObjectCount++;
                                        }
                                        findCombatData(obj[key], `${path}.${key}`);
                                    });
                                }
                            };
                            
                            findCombatData(jsonData);
                            analysis.statistics.totalLines = JSON.stringify(jsonData, null, 2).split('\n').length;
                            
                        } catch (e) {
                            console.error('Error parsing JSON:', e);
                            // Fall back to text parsing
                        }
                        
                    } else {
                        // Parse text/log files line by line
                        const lines = text.split('\n');
                        analysis.statistics.totalLines = lines.length;
                        
                        lines.forEach((line, index) => {
                            const lineNumber = index + 1;
                        
                        // Detect GameObject creation/distribution (based on CreateGoObjAndDistrObjView function)
                        if (line.match(/CreateGoObjAndDistrObjView|GameObject|0xCA7/i)) {
                            const hexMatch = line.match(/0x[0-9A-F]+/gi);
                            analysis.gameObjects.push({
                                line: lineNumber,
                                content: line.trim(),
                                objectId: hexMatch ? hexMatch[0] : 'unknown',
                                timestamp: extractTimestamp(line)
                            });
                            analysis.statistics.gameObjectCount++;
                        }
                        
                        // Detect combat-related messages (expanded patterns for MXO)
                        if (line.match(/damage|accuracy|defense|combat|interlock|d100|roll|pvp|duel|melee|ranged|viral|hack|block|evade|critical|resistance|buff|debuff|dot|heal|stun|root|mezz|taunt|aggro|threat|style|combo|finisher|powerless|disarm|pacify|confuse|blind|slow/i)) {
                            analysis.combatMessages.push({
                                line: lineNumber,
                                content: line.trim(),
                                type: getCombatType(line),
                                timestamp: extractTimestamp(line),
                                values: extractCombatValues(line)
                            });
                            analysis.statistics.combatEventCount++;
                        }
                        
                        // Detect RPC calls (Protocol 04)
                        if (line.match(/RPC|8113|8114|8115|Remote Procedure/i)) {
                            const rpcIdMatch = line.match(/\b\d{4}\b/);
                            analysis.rpcCalls.push({
                                line: lineNumber,
                                content: line.trim(),
                                rpcId: rpcIdMatch ? rpcIdMatch[0] : 'unknown',
                                timestamp: extractTimestamp(line)
                            });
                            analysis.statistics.rpcCallCount++;
                        }
                        
                        // Detect packet data (hex dumps, Protocol 03/04)
                        if (line.match(/packet|protocol|0x[0-9A-F]{2,}/i) || line.match(/([0-9A-F]{2}\s){4,}/i)) {
                            analysis.packetData.push({
                                line: lineNumber,
                                content: line.trim(),
                                protocol: getProtocolType(line),
                                timestamp: extractTimestamp(line)
                            });
                            analysis.statistics.packetCount++;
                        }
                        
                        // Detect animation IDs (interlock system)
                        if (line.match(/animation|anim_id|\bID:\s*\d+/i)) {
                            const animIdMatch = line.match(/\b\d{3,4}\b/);
                            if (animIdMatch) {
                                analysis.animationIds.push({
                                    line: lineNumber,
                                    content: line.trim(),
                                    animationId: animIdMatch[0],
                                    timestamp: extractTimestamp(line)
                                });
                            }
                        }
                        });
                    }
                    
                    return analysis;
                } catch (error) {
                    console.error('Error analyzing log file:', error);
                    return null;
                }
            };
            
            // Helper functions for log analysis
            const extractTimestamp = (line) => {
                const timeMatch = line.match(/\d{2}:\d{2}:\d{2}|\d{4}-\d{2}-\d{2}|\[\d+\]/);
                return timeMatch ? timeMatch[0] : null;
            };
            
            const getCombatType = (line) => {
                const lineLower = line.toLowerCase();
                
                // Damage types
                if (lineLower.includes('damage')) return 'damage';
                if (lineLower.includes('critical')) return 'critical';
                if (lineLower.includes('dot')) return 'damage_over_time';
                
                // Attack types
                if (lineLower.includes('melee')) return 'melee';
                if (lineLower.includes('ranged')) return 'ranged';
                if (lineLower.includes('viral')) return 'viral';
                if (lineLower.includes('hack')) return 'hack';
                
                // Defense types
                if (lineLower.includes('defense') || lineLower.includes('dodge')) return 'defense';
                if (lineLower.includes('block')) return 'block';
                if (lineLower.includes('evade')) return 'evade';
                if (lineLower.includes('resistance')) return 'resistance';
                
                // Accuracy and rolls
                if (lineLower.includes('accuracy') || lineLower.includes('hit')) return 'accuracy';
                if (lineLower.includes('d100') || lineLower.includes('roll')) return 'dice_roll';
                
                // Combat states
                if (lineLower.includes('interlock')) return 'interlock';
                if (lineLower.includes('pvp')) return 'pvp';
                if (lineLower.includes('duel')) return 'duel';
                
                // Buffs and debuffs
                if (lineLower.includes('buff')) return 'buff';
                if (lineLower.includes('debuff')) return 'debuff';
                if (lineLower.includes('heal')) return 'heal';
                
                // Crowd control
                if (lineLower.includes('stun')) return 'stun';
                if (lineLower.includes('root')) return 'root';
                if (lineLower.includes('mezz')) return 'mezz';
                if (lineLower.includes('slow')) return 'slow';
                if (lineLower.includes('confuse')) return 'confuse';
                if (lineLower.includes('blind')) return 'blind';
                if (lineLower.includes('powerless')) return 'powerless';
                if (lineLower.includes('disarm')) return 'disarm';
                if (lineLower.includes('pacify')) return 'pacify';
                
                // Threat management
                if (lineLower.includes('taunt')) return 'taunt';
                if (lineLower.includes('aggro') || lineLower.includes('threat')) return 'threat';
                
                // Combat styles
                if (lineLower.includes('style')) return 'style';
                if (lineLower.includes('combo')) return 'combo';
                if (lineLower.includes('finisher')) return 'finisher';
                
                return 'general';
            };
            
            // Extract numeric values from combat messages
            const extractCombatValues = (line) => {
                const values = {};
                
                // Extract damage numbers
                const damageMatch = line.match(/(\d+)\s*damage/i);
                if (damageMatch) values.damage = parseInt(damageMatch[1]);
                
                // Extract percentages
                const percentMatch = line.match(/(\d+)%/);
                if (percentMatch) values.percentage = parseInt(percentMatch[1]);
                
                // Extract dice rolls
                const rollMatch = line.match(/\bd(\d+)\s*[:=]\s*(\d+)/i);
                if (rollMatch) {
                    values.diceType = `d${rollMatch[1]}`;
                    values.rollResult = parseInt(rollMatch[2]);
                }
                
                // Extract any other numbers
                const numbers = line.match(/\b\d+\b/g);
                if (numbers && numbers.length > 0) {
                    values.numbers = numbers.map(n => parseInt(n));
                }
                
                return Object.keys(values).length > 0 ? values : null;
            };
            
            const getProtocolType = (line) => {
                if (line.match(/protocol\s*03|GameObject/i)) return 'Protocol 03 (GameObject)';
                if (line.match(/protocol\s*04|RPC/i)) return 'Protocol 04 (RPC)';
                return 'Unknown Protocol';
            };
            
            // Handle log file selection
            const handleLogSelect = async (logFileInfo) => {
                setSelectedLog(logFileInfo);
                setAnalyzedData(null);
                setIsAnalyzing(true);
                
                try {
                    const analysis = await analyzeLogFile(logFileInfo.file);
                    setAnalyzedData(analysis);
                } catch (error) {
                    console.error('Error analyzing log file:', error);
                } finally {
                    setIsAnalyzing(false);
                }
            };
            
            // Get filtered and sorted log files
            const getFilteredAndSortedLogFiles = () => {
                let filtered = logFiles.filter(logFile => {
                    // Category filter
                    if (categoryFilter !== 'all' && logFile.category !== categoryFilter) {
                        return false;
                    }
                    
                    // Search term filter
                    if (searchTerm) {
                        const searchLower = searchTerm.toLowerCase();
                        return logFile.name.toLowerCase().includes(searchLower) ||
                               logFile.path.toLowerCase().includes(searchLower) ||
                               logFile.tags.some(tag => tag.includes(searchLower));
                    }
                    
                    return true;
                });
                
                // Sort files
                filtered.sort((a, b) => {
                    let aValue, bValue;
                    
                    switch (sortBy) {
                        case 'name':
                            aValue = a.name.toLowerCase();
                            bValue = b.name.toLowerCase();
                            break;
                        case 'size':
                            aValue = a.size;
                            bValue = b.size;
                            break;
                        case 'category':
                            aValue = a.category;
                            bValue = b.category;
                            break;
                        case 'path':
                            aValue = a.path.toLowerCase();
                            bValue = b.path.toLowerCase();
                            break;
                        default:
                            aValue = a.name.toLowerCase();
                            bValue = b.name.toLowerCase();
                    }
                    
                    if (aValue < bValue) return sortOrder === 'asc' ? -1 : 1;
                    if (aValue > bValue) return sortOrder === 'asc' ? 1 : -1;
                    return 0;
                });
                
                return filtered;
            };
            
            // Get unique categories for filter dropdown
            const getUniqueCategories = () => {
                const categories = [...new Set(logFiles.map(f => f.category))];
                return categories.sort();
            };
            
            // Get unique tags for display
            const getUniqueTags = () => {
                const allTags = logFiles.flatMap(f => f.tags);
                return [...new Set(allTags)].sort();
            };
            
            // Filter data based on search and filter type
            const getFilteredData = (dataArray) => {
                if (!dataArray) return [];
                
                return dataArray.filter(item => {
                    const matchesSearch = !searchTerm || 
                        item.content.toLowerCase().includes(searchTerm.toLowerCase());
                    
                    if (filterType === 'all') return matchesSearch;
                    
                    if (filterType === 'combat' && item.type) {
                        return matchesSearch && ['damage', 'accuracy', 'defense', 'dice_roll', 'interlock'].includes(item.type);
                    }
                    
                    return matchesSearch;
                });
            };
            
            return (
                <div className="p-4" style={{ height: 'calc(100vh - 100px)', overflowY: 'auto' }}>
                    <h3 className="matrix-title mb-4">GameObject & Combat Analyzer - Enhanced for Matrix Online</h3>
                    <p className="text-xs mb-2 opacity-70">
                        Analyzes combat logs, XML configs, JSON data, .gob files, and various MXO-specific file formats
                    </p>
                    
                    {/* Critical Information Alert */}
                    <div className="bg-red-900 bg-opacity-20 border border-red-500 p-3 rounded mb-3">
                        <h4 className="text-sm font-bold mb-1 text-red-400">🔑 Critical: 44,000 GameObjects (.gob files)</h4>
                        <p className="text-xs mb-1">
                            <strong>Key to MXO:</strong> ~44k GameObject files define everything in the world.
                        </p>
                        <p className="text-xs mb-1">
                            <strong>The Challenge:</strong> Decode the hex structure - understand what each byte represents.
                        </p>
                        <p className="text-xs">
                            <strong>Expert Advice:</strong> "You have to flail at it until you understand it." - Morpheus
                        </p>
                    </div>
                    
                    {/* PKB Archive Information */}
                    <div className="bg-yellow-900 bg-opacity-20 border border-yellow-500 p-3 rounded mb-4">
                        <h4 className="text-sm font-bold mb-1 text-yellow-400">📦 Models Packed in PKB Archives</h4>
                        <p className="text-xs mb-1">
                            Most .moa/.prop files are in .pkb archives (packmaps/ directory)
                        </p>
                        <ul className="list-disc list-inside text-xs space-y-0.5 ml-3">
                            <li><strong>char_npc.pkb</strong> - NPC models</li>
                            <li><strong>zmisc_1.pkb</strong> - Misc assets</li>
                            <li><strong>packmap_save.lta</strong> - File index</li>
                        </ul>
                        <p className="text-xs mt-1 text-gray-400">
                            Use the Archive Browser to extract from PKB files.
                        </p>
                    </div>
                    
                    {/* File Summary */}
                    <div className="mb-4 p-4 border border-green-500 rounded">
                        <div className="flex justify-between items-center mb-2">
                            <h4 className="text-sm font-bold">Log Files Found: {logFiles.length}</h4>
                            <div className="text-xs">
                                Categories: {getUniqueCategories().length} | Tags: {getUniqueTags().length}
                            </div>
                        </div>
                        
                        {logFiles.length === 0 && (
                            <div className="text-center p-4 opacity-70">
                                <p>No combat-related files found in loaded directory</p>
                                <p className="text-xs mt-2">Load a directory containing:</p>
                                <ul className="text-xs mt-2">
                                    <li>• Log files (.log, .txt, .out)</li>
                                    <li>• GameObject files (.gob)</li>
                                    <li>• Combat configs (.xml, .json, .cfg)</li>
                                    <li>• Data files (.dat, .csv)</li>
                                    <li>• PKB archives from packmaps/</li>
                                    <li>• Files with combat keywords in name</li>
                                </ul>
                            </div>
                        )}
                    </div>
                    
                    {logFiles.length > 0 && (
                        <>
                            {/* Filtering and Sorting Controls */}
                            <div className="mb-4 p-4 border border-green-500 rounded">
                                <h4 className="text-sm font-bold mb-3">Filters & Sorting</h4>
                                
                                <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                                    {/* Search */}
                                    <div>
                                        <label className="text-xs block mb-1">Search Files:</label>
                                        <input 
                                            type="text"
                                            placeholder="Name, path, or tags..."
                                            value={searchTerm}
                                            onChange={(e) => setSearchTerm(e.target.value)}
                                            className="w-full p-2 text-xs bg-black border border-green-500 text-green-400"
                                        />
                                    </div>
                                    
                                    {/* Category Filter */}
                                    <div>
                                        <label className="text-xs block mb-1">Category:</label>
                                        <select 
                                            value={categoryFilter}
                                            onChange={(e) => setCategoryFilter(e.target.value)}
                                            className="w-full p-2 text-xs bg-black border border-green-500 text-green-400"
                                        >
                                            <option value="all">All Categories</option>
                                            {getUniqueCategories().map(cat => (
                                                <option key={cat} value={cat}>{cat.charAt(0).toUpperCase() + cat.slice(1)}</option>
                                            ))}
                                        </select>
                                    </div>
                                    
                                    {/* Sort By */}
                                    <div>
                                        <label className="text-xs block mb-1">Sort By:</label>
                                        <select 
                                            value={sortBy}
                                            onChange={(e) => setSortBy(e.target.value)}
                                            className="w-full p-2 text-xs bg-black border border-green-500 text-green-400"
                                        >
                                            <option value="name">Name</option>
                                            <option value="size">Size</option>
                                            <option value="category">Category</option>
                                            <option value="path">Path</option>
                                        </select>
                                    </div>
                                    
                                    {/* Sort Order */}
                                    <div>
                                        <label className="text-xs block mb-1">Order:</label>
                                        <select 
                                            value={sortOrder}
                                            onChange={(e) => setSortOrder(e.target.value)}
                                            className="w-full p-2 text-xs bg-black border border-green-500 text-green-400"
                                        >
                                            <option value="asc">Ascending</option>
                                            <option value="desc">Descending</option>
                                        </select>
                                    </div>
                                </div>
                                
                                {/* Quick Filter Tags */}
                                <div>
                                    <label className="text-xs block mb-2">Quick Tag Filters:</label>
                                    <div className="flex flex-wrap gap-2">
                                        {getUniqueTags().slice(0, 10).map(tag => (
                                            <button
                                                key={tag}
                                                className="px-2 py-1 text-xs border border-green-500 rounded hover:bg-green-900 hover:bg-opacity-30"
                                                onClick={() => setSearchTerm(tag)}
                                            >
                                                #{tag}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                            
                            {/* File List */}
                            <div className="mb-4 p-4 border border-green-500 rounded">
                                <h4 className="text-sm font-bold mb-3">
                                    Log Files ({getFilteredAndSortedLogFiles().length} of {logFiles.length})
                                </h4>
                                
                                <div className="grid grid-cols-1 gap-2 max-h-64 overflow-y-auto">
                                    {getFilteredAndSortedLogFiles().map((logFile, index) => (
                                        <div 
                                            key={index}
                                            className={`p-3 border cursor-pointer text-sm hover:bg-green-900 hover:bg-opacity-20 ${
                                                selectedLog === logFile ? 'bg-green-900 bg-opacity-30 border-green-400' : 'border-green-700'
                                            }`}
                                            onClick={() => handleLogSelect(logFile)}
                                        >
                                            <div className="flex justify-between items-start mb-1">
                                                <div className="font-bold">{logFile.name}</div>
                                                <div className="flex items-center gap-2">
                                                    <span className="text-xs px-2 py-1 bg-green-800 rounded">
                                                        {logFile.category}
                                                    </span>
                                                    <span className="text-xs opacity-70">
                                                        {Math.floor(logFile.size / 1024)} KB
                                                    </span>
                                                </div>
                                            </div>
                                            <div className="text-xs opacity-70 mb-2">{logFile.path}</div>
                                            {logFile.tags.length > 0 && (
                                                <div className="flex flex-wrap gap-1">
                                                    {logFile.tags.slice(0, 5).map(tag => (
                                                        <span key={tag} className="text-xs px-1 py-0.5 bg-black bg-opacity-50 rounded">
                                                            #{tag}
                                                        </span>
                                                    ))}
                                                    {logFile.tags.length > 5 && (
                                                        <span className="text-xs opacity-50">+{logFile.tags.length - 5} more</span>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                    
                                    {getFilteredAndSortedLogFiles().length === 0 && (
                                        <div className="text-center p-8 opacity-70">
                                            No log files match the current filters
                                        </div>
                                    )}
                                </div>
                            </div>
                        </>
                    )}
                    
                    {/* Analysis Loading */}
                    {isAnalyzing && (
                        <div className="mb-4 p-4 border border-green-500 rounded">
                            <div className="flex items-center justify-center">
                                <div className="inline-block w-6 h-6 border-t-2 border-r-2 border-green-500 rounded-full animate-spin mr-3"></div>
                                <span>Analyzing log file...</span>
                            </div>
                        </div>
                    )}
                    
                    {analyzedData && !isAnalyzing && (
                        <>
                            {/* Selected File Info */}
                            <div className="mb-4 p-4 border border-green-500 rounded">
                                <h4 className="text-sm font-bold mb-2">Analyzing: {selectedLog?.name}</h4>
                                <div className="text-xs opacity-70">
                                    <div>Path: {selectedLog?.path}</div>
                                    <div>Category: {selectedLog?.category}</div>
                                    <div>Size: {Math.floor(selectedLog?.size / 1024)} KB</div>
                                    {selectedLog?.tags.length > 0 && (
                                        <div className="mt-1">
                                            Tags: {selectedLog.tags.map(tag => `#${tag}`).join(', ')}
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {/* Statistics Overview */}
                            <div className="mb-4 p-4 border border-green-500 rounded">
                                <h4 className="text-sm font-bold mb-2">Analysis Statistics</h4>
                                <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                                    <div className="text-center">
                                        <div className="text-lg font-bold">{analyzedData.statistics.totalLines}</div>
                                        <div className="text-xs">Total Lines</div>
                                    </div>
                                    <div className="text-center">
                                        <div className="text-lg font-bold">{analyzedData.statistics.gameObjectCount}</div>
                                        <div className="text-xs">GameObjects</div>
                                    </div>
                                    <div className="text-center">
                                        <div className="text-lg font-bold">{analyzedData.statistics.combatEventCount}</div>
                                        <div className="text-xs">Combat Events</div>
                                    </div>
                                    <div className="text-center">
                                        <div className="text-lg font-bold">{analyzedData.statistics.rpcCallCount}</div>
                                        <div className="text-xs">RPC Calls</div>
                                    </div>
                                    <div className="text-center">
                                        <div className="text-lg font-bold">{analyzedData.statistics.packetCount}</div>
                                        <div className="text-xs">Packets</div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Search and Filter */}
                            <div className="mb-4 flex gap-4">
                                <input 
                                    type="text"
                                    placeholder="Search log entries..."
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                    className="flex-grow p-2 bg-black border border-green-500 text-green-400"
                                />
                                <select 
                                    value={filterType}
                                    onChange={(e) => setFilterType(e.target.value)}
                                    className="p-2 bg-black border border-green-500 text-green-400"
                                >
                                    <option value="all">All Events</option>
                                    <option value="combat">Combat Only</option>
                                </select>
                            </div>
                            
                            {/* Tabs */}
                            <div className="border-b border-green-900 mb-4">
                                <div className="flex">
                                    {[
                                        { id: 'overview', label: 'Overview' },
                                        { id: 'gameobjects', label: `GameObjects (${analyzedData.statistics.gameObjectCount})` },
                                        { id: 'combat', label: `Combat (${analyzedData.statistics.combatEventCount})` },
                                        { id: 'rpc', label: `RPC Calls (${analyzedData.statistics.rpcCallCount})` },
                                        { id: 'packets', label: `Packets (${analyzedData.statistics.packetCount})` },
                                        { id: 'animations', label: `Animations (${analyzedData.animationIds.length})` }
                                    ].map(tab => (
                                        <div 
                                            key={tab.id}
                                            className={`px-4 py-2 cursor-pointer text-xs ${
                                                activeTab === tab.id ? 'bg-green-900 text-green-100' : 'text-green-500'
                                            }`}
                                            onClick={() => setActiveTab(tab.id)}
                                        >
                                            {tab.label}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            
                            {/* Tab Content */}
                            {activeTab === 'overview' && (
                                <div>
                                    <h4 className="text-sm font-bold mb-4">Matrix Online Technical Overview</h4>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div className="p-4 border border-green-500 rounded">
                                            <h5 className="font-bold mb-2">GameObject System</h5>
                                            <p className="text-sm mb-2">Total Objects: 40,000+ in system</p>
                                            <p className="text-sm mb-2">Function: CreateGoObjAndDistrObjView()</p>
                                            <p className="text-sm">Found {analyzedData.statistics.gameObjectCount} GameObject events in this log</p>
                                        </div>
                                        <div className="p-4 border border-green-500 rounded">
                                            <h5 className="font-bold mb-2">Combat System</h5>
                                            <p className="text-sm mb-2">Type: D100 roll-based system</p>
                                            <p className="text-sm mb-2">Grid-based interlock combat</p>
                                            <p className="text-sm">Found {analyzedData.statistics.combatEventCount} combat events in this log</p>
                                        </div>
                                        <div className="p-4 border border-green-500 rounded">
                                            <h5 className="font-bold mb-2">Network Protocols</h5>
                                            <p className="text-sm mb-2">Protocol 03: GameObject distribution</p>
                                            <p className="text-sm mb-2">Protocol 04: RPC calls</p>
                                            <p className="text-sm">Found {analyzedData.statistics.rpcCallCount} RPC calls in this log</p>
                                        </div>
                                        <div className="p-4 border border-green-500 rounded">
                                            <h5 className="font-bold mb-2">Animation System</h5>
                                            <p className="text-sm mb-2">Server-controlled animation sync</p>
                                            <p className="text-sm mb-2">Interlock grid positioning</p>
                                            <p className="text-sm">Found {analyzedData.animationIds.length} animation references</p>
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            {activeTab === 'gameobjects' && (
                                <div>
                                    <h4 className="text-sm font-bold mb-4">GameObject Creation & Distribution Events</h4>
                                    <div className="space-y-2 max-h-96 overflow-y-auto">
                                        {getFilteredData(analyzedData.gameObjects).map((event, index) => (
                                            <div key={index} className="p-3 border border-green-500 rounded text-sm">
                                                <div className="flex justify-between items-start mb-2">
                                                    <span className="font-bold">Object ID: {event.objectId}</span>
                                                    <span className="text-xs opacity-70">Line {event.line}</span>
                                                </div>
                                                <div className="font-mono text-xs bg-black bg-opacity-50 p-2 rounded">
                                                    {event.content}
                                                </div>
                                                {event.timestamp && (
                                                    <div className="text-xs opacity-70 mt-1">
                                                        Timestamp: {event.timestamp}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                        {getFilteredData(analyzedData.gameObjects).length === 0 && (
                                            <div className="text-center p-8 opacity-70">
                                                No GameObject events found matching current filters
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                            
                            {activeTab === 'combat' && (
                                <div>
                                    <h4 className="text-sm font-bold mb-4">Combat System Events</h4>
                                    <div className="space-y-2 max-h-96 overflow-y-auto">
                                        {getFilteredData(analyzedData.combatMessages).map((event, index) => (
                                            <div key={index} className="p-3 border border-green-500 rounded text-sm">
                                                <div className="flex justify-between items-start mb-2">
                                                    <span className="font-bold capitalize">{event.type.replace('_', ' ')}</span>
                                                    <span className="text-xs opacity-70">Line {event.line}</span>
                                                </div>
                                                <div className="font-mono text-xs bg-black bg-opacity-50 p-2 rounded">
                                                    {event.content}
                                                </div>
                                                {event.timestamp && (
                                                    <div className="text-xs opacity-70 mt-1">
                                                        Timestamp: {event.timestamp}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                        {getFilteredData(analyzedData.combatMessages).length === 0 && (
                                            <div className="text-center p-8 opacity-70">
                                                No combat events found matching current filters
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                            
                            {activeTab === 'rpc' && (
                                <div>
                                    <h4 className="text-sm font-bold mb-4">RPC (Remote Procedure Call) Events</h4>
                                    <div className="space-y-2 max-h-96 overflow-y-auto">
                                        {getFilteredData(analyzedData.rpcCalls).map((event, index) => (
                                            <div key={index} className="p-3 border border-green-500 rounded text-sm">
                                                <div className="flex justify-between items-start mb-2">
                                                    <span className="font-bold">RPC ID: {event.rpcId}</span>
                                                    <span className="text-xs opacity-70">Line {event.line}</span>
                                                </div>
                                                <div className="font-mono text-xs bg-black bg-opacity-50 p-2 rounded">
                                                    {event.content}
                                                </div>
                                                {event.timestamp && (
                                                    <div className="text-xs opacity-70 mt-1">
                                                        Timestamp: {event.timestamp}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                        {getFilteredData(analyzedData.rpcCalls).length === 0 && (
                                            <div className="text-center p-8 opacity-70">
                                                No RPC events found matching current filters
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                            
                            {activeTab === 'packets' && (
                                <div>
                                    <h4 className="text-sm font-bold mb-4">Network Packet Data</h4>
                                    <div className="space-y-2 max-h-96 overflow-y-auto">
                                        {getFilteredData(analyzedData.packetData).map((event, index) => (
                                            <div key={index} className="p-3 border border-green-500 rounded text-sm">
                                                <div className="flex justify-between items-start mb-2">
                                                    <span className="font-bold">{event.protocol}</span>
                                                    <span className="text-xs opacity-70">Line {event.line}</span>
                                                </div>
                                                <div className="font-mono text-xs bg-black bg-opacity-50 p-2 rounded">
                                                    {event.content}
                                                </div>
                                                {event.timestamp && (
                                                    <div className="text-xs opacity-70 mt-1">
                                                        Timestamp: {event.timestamp}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                        {getFilteredData(analyzedData.packetData).length === 0 && (
                                            <div className="text-center p-8 opacity-70">
                                                No packet data found matching current filters
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                            
                            {activeTab === 'animations' && (
                                <div>
                                    <h4 className="text-sm font-bold mb-4">Animation ID References</h4>
                                    <div className="space-y-2 max-h-96 overflow-y-auto">
                                        {getFilteredData(analyzedData.animationIds).map((event, index) => (
                                            <div key={index} className="p-3 border border-green-500 rounded text-sm">
                                                <div className="flex justify-between items-start mb-2">
                                                    <span className="font-bold">Animation ID: {event.animationId}</span>
                                                    <span className="text-xs opacity-70">Line {event.line}</span>
                                                </div>
                                                <div className="font-mono text-xs bg-black bg-opacity-50 p-2 rounded">
                                                    {event.content}
                                                </div>
                                                {event.timestamp && (
                                                    <div className="text-xs opacity-70 mt-1">
                                                        Timestamp: {event.timestamp}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                        {getFilteredData(analyzedData.animationIds).length === 0 && (
                                            <div className="text-center p-8 opacity-70">
                                                No animation references found matching current filters
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                        </>
                    )}
                    
                    {!selectedLog && logFiles.length > 0 && (
                        <div className="text-center p-8 opacity-70">
                            <p>Select a log file above to begin analysis</p>
                            <div className="mt-4 text-xs">
                                <h5 className="font-bold mb-2">What this analyzer looks for:</h5>
                                <ul className="text-left inline-block">
                                    <li>• GameObject creation (CreateGoObjAndDistrObjView)</li>
                                    <li>• Combat events (damage, accuracy, defense)</li>
                                    <li>• RPC calls (8113, 8114, 8115)</li>
                                    <li>• Network packet data</li>
                                    <li>• Animation IDs for interlock system</li>
                                </ul>
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        
        // Performance monitoring utility
        window.performanceMonitor = {
            start: (operation) => {
                const startTime = performance.now();
                const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                return {
                    operation,
                    startTime,
                    startMemory,
                    end: () => {
                        const endTime = performance.now();
                        const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                        const duration = endTime - startTime;
                        const memoryUsed = endMemory - startMemory;
                        
                        console.log(`Performance [${operation}]: ${duration.toFixed(2)}ms, Memory: ${(memoryUsed / 1024 / 1024).toFixed(2)}MB`);
                        
                        if (duration > 5000) {
                            console.warn(`Slow operation detected: ${operation} took ${duration.toFixed(2)}ms`);
                        }
                        
                        return { duration, memoryUsed };
                    }
                };
            }
        };

        // Helper function to extract files from PKB using index
        window.extractFromPKB = async (pkbFileName) => {
            const perf = window.performanceMonitor.start(`PKB Extraction: ${pkbFileName}`);
            
            if (!window.MXO_PKB_INDEX_DATA) {
                console.error('No index file loaded. Please load packmap_save.lta first.');
                perf.end();
                return [];
            }
            
            const pkbData = window.MXO_PKB_FILES && window.MXO_PKB_FILES[pkbFileName.toLowerCase()];
            if (!pkbData) {
                console.error(`PKB file ${pkbFileName} not loaded`);
                return [];
            }
            
            console.log(`Attempting to extract from ${pkbFileName} using index`);
            
            // Parse the packmap_save.lta index
            // The format appears to be binary with file entries
            const indexData = window.MXO_PKB_INDEX_DATA;
            const decoder = new TextDecoder('ascii');
            const extractedFiles = [];
            
            try {
                // Try to find references to this PKB file in the index
                const pkbNameBytes = new TextEncoder().encode(pkbFileName);
                
                // Search for file entries in the index
                // This is a simplified parser - the actual format may be more complex
                for (let i = 0; i < indexData.length - 100; i++) {
                    // Look for .moa, .prop, or other file extensions
                    if (indexData[i] === 0x2E) { // '.' character
                        // Check for known extensions
                        const ext3 = decoder.decode(indexData.slice(i, i + 4)).toLowerCase();
                        const ext4 = decoder.decode(indexData.slice(i, i + 5)).toLowerCase();
                        
                        if (ext3 === '.moa' || ext4 === '.prop' || ext3 === '.txa' || ext3 === '.txb') {
                            // Found a potential file entry
                            // Try to read the filename backwards
                            let start = i - 1;
                            while (start > 0 && indexData[start] >= 32 && indexData[start] < 127) {
                                start--;
                            }
                            start++;
                            
                            const filename = decoder.decode(indexData.slice(start, i + (ext4.startsWith('.prop') ? 5 : 4)));
                            
                            // Skip if filename is too short or contains invalid characters
                            if (filename.length < 5 || filename.includes('\0')) continue;
                            
                            // Look for offset and size after the filename
                            // This is speculative - actual format may differ
                            let offset = i + (ext4.startsWith('.prop') ? 5 : 4);
                            
                            // Skip nulls or padding
                            while (offset < indexData.length && indexData[offset] === 0) offset++;
                            
                            if (offset + 8 <= indexData.length) {
                                // Try to read offset and size as 32-bit integers
                                const view = new DataView(indexData.buffer, offset);
                                const fileOffset = view.getUint32(0, true); // little-endian
                                const fileSize = view.getUint32(4, true);
                                
                                // Sanity check
                                if (fileOffset < pkbData.byteLength && fileSize > 0 && fileSize < 10000000) {
                                    // Extract the file data from PKB
                                    const fileData = new Uint8Array(pkbData, fileOffset, Math.min(fileSize, pkbData.byteLength - fileOffset));
                                    
                                    extractedFiles.push({
                                        name: filename,
                                        size: fileSize,
                                        offset: fileOffset,
                                        data: fileData
                                    });
                                    
                                    console.log(`Found file: ${filename} at offset ${fileOffset}, size ${fileSize}`);
                                }
                            }
                        }
                    }
                }
                
                // If no files found with the above method, try a different approach
                if (extractedFiles.length === 0) {
                    console.log('No files found with first method, trying alternative parsing...');
                    
                    // Add some dummy files for testing
                    // In reality, we need the proper packmap_save.lta format specification
                    if (pkbFileName.includes('worlds')) {
                        extractedFiles.push({
                            name: 'world_test.prop',
                            size: 1024,
                            offset: 0,
                            data: new Uint8Array(1024).fill(0)
                        });
                    }
                }
                
            } catch (error) {
                console.error('Error parsing index:', error);
            }
            
            console.log(`Extracted ${extractedFiles.length} files from ${pkbFileName}`);
            perf.end();
            return extractedFiles;
        };
        
        // Global error handler for better user experience
        window.handleError = (error, context = 'Unknown') => {
            console.error(`Error in ${context}:`, error);
            
            // Create user-friendly error messages
            let userMessage = 'An error occurred';
            
            if (error.message.includes('out of memory')) {
                userMessage = 'Not enough memory to process this file. Try with a smaller file or refresh the page.';
            } else if (error.message.includes('network')) {
                userMessage = 'Network error. Check your connection and try again.';
            } else if (error.message.includes('format') || error.message.includes('parse')) {
                userMessage = 'This file format is not supported or the file is corrupted.';
            } else if (error.message.includes('permission')) {
                userMessage = 'Permission denied. Make sure you have access to this file.';
            }
            
            // Show error to user with option to report
            const shouldReport = confirm(`${userMessage}\n\nWould you like to copy error details for reporting?`);
            
            if (shouldReport) {
                const errorDetails = `MOMS Error Report
Context: ${context}
Error: ${error.message}
Stack: ${error.stack}
Timestamp: ${new Date().toISOString()}
URL: ${window.location.href}
User Agent: ${navigator.userAgent}`;
                
                navigator.clipboard.writeText(errorDetails).then(() => {
                    alert('Error details copied to clipboard. You can report this on GitHub.');
                }).catch(() => {
                    console.log('Error details:', errorDetails);
                    alert('Error details logged to console. Please copy and report on GitHub.');
                });
            }
        };

        // Main App Component
        const App = () => {
            const [files, setFiles] = useState({});
            const [allFiles, setAllFiles] = useState({});
            const [selectedFilePath, setSelectedFilePath] = useState(null);
            const [selectedFile, setSelectedFile] = useState(null);
            const [fileData, setFileData] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [activeView, setActiveView] = useState('explorer');
            const [modelFilter, setModelFilter] = useState('all');
            
            // Make filter accessible globally for the filter buttons
            useEffect(() => {
                window.modelFilter = modelFilter;
                window.setModelFilter = setModelFilter;
            }, [modelFilter]);
            
            // Handle directory selection
            const handleDirectorySelect = (e) => {
                const dirInput = e.target;
                
                if (dirInput.files.length === 0) return;
                
                setIsLoading(true);
                
                // Process files and organize into a tree structure
                const fileTree = {};
                const flatFiles = {};
                const filePromises = [];
                
                for (let i = 0; i < dirInput.files.length; i++) {
                    const file = dirInput.files[i];
                    const path = file.webkitRelativePath;
                    const pathParts = path.split('/');
                    
                    // Skip hidden files
                    if (pathParts.some(part => part.startsWith('.'))) continue;
                    
                    // Add to flat structure for type-based views
                    flatFiles[path] = {
                        type: 'file',
                        file: file
                    };
                    
                    // Build tree structure
                    let currentLevel = fileTree;
                    for (let j = 0; j < pathParts.length - 1; j++) {
                        const part = pathParts[j];
                        if (!currentLevel[part]) {
                            currentLevel[part] = {
                                type: 'folder',
                                children: {}
                            };
                        }
                        currentLevel = currentLevel[part].children;
                    }
                    
                    // Add file
                    const fileName = pathParts[pathParts.length - 1];
                    currentLevel[fileName] = {
                        type: 'file',
                        file: file
                    };
                    
                    filePromises.push(Promise.resolve());
                }
                
                // Wait for all files to be processed
                Promise.all(filePromises)
                    .then(() => {
                        setFiles(fileTree);
                        setAllFiles(flatFiles);
                        setIsLoading(false);
                    })
                    .catch(error => {
                        console.error('Error processing files:', error);
                        setIsLoading(false);
                        alert('Error processing files. See console for details.');
                    });
            };
            
            // Handle file selection from tree
            const handleFileSelect = async (path, fileInfo) => {
                if (fileInfo.type !== 'file' || !fileInfo.file) return;
                
                setSelectedFilePath(path);
                setSelectedFile(fileInfo.file);
                setFileData(null);
                setIsLoading(true);
                
                try {
                    // Parse file based on type
                    const fileName = path.split('/').pop();
                    const fileExt = '.' + fileName.split('.').pop().toLowerCase();
                    
                    let parsedData = null;
                    
                    if (FILE_TYPES.MODEL.extensions.includes(fileExt)) {
                        try {
                            // For 3D models, parse and prepare for display
                            console.log(`Processing 3D model: ${fileName}`);
                            
                            // Use specific parser based on file extension
                            if (fileExt === '.prop') {
                                parsedData = await LithtechParsers.parsePROP(fileInfo.file);
                            } else if (fileExt === '.moa' || fileExt === '.iprf' || fileExt === '.eprf') {
                                parsedData = await LithtechParsers.parseMOA(fileInfo.file);
                            } else if (fileExt === '.mga' || fileExt === '.mgc') {
                                parsedData = await LithtechParsers.parseMGA(fileInfo.file);
                            } else {
                                parsedData = await LithtechParsers.parseABC(fileInfo.file);
                            }
                            
                            // If this is coming from the models tab, automatically focus the 3D view
                            if (activeView === 'models') {
                                parsedData.initialTab = 'view';
                            }
                        } catch (error) {
                            console.error('Error parsing 3D model:', error);
                            // Provide a placeholder model if parsing fails
                            parsedData = {
                                type: 'model',
                                vertices: [],
                                indices: [],
                                uvs: [],
                                normals: [],
                                animations: [],
                                materials: [],
                                metadata: {
                                    format: fileExt === '.abc' ? 'ABC' : 'MOB',
                                    version: 1.0,
                                    error: 'Could not parse model file'
                                }
                            };
                        }
                    } else if (FILE_TYPES.TEXTURE.extensions.includes(fileExt)) {
                        try {
                            // For texture files
                            console.log(`Processing texture: ${fileName}`);
                            parsedData = await LithtechParsers.parseTexture(fileInfo.file);
                        } catch (error) {
                            console.error('Error parsing texture:', error);
                            // Create a placeholder texture
                            const canvas = document.createElement('canvas');
                            canvas.width = 256;
                            canvas.height = 256;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = '#001a00';
                            ctx.fillRect(0, 0, 256, 256);
                            ctx.strokeStyle = '#00ff00';
                            ctx.strokeRect(0, 0, 256, 256);
                            ctx.font = '14px monospace';
                            ctx.fillStyle = '#00ff00';
                            ctx.fillText(`Error: Could not parse ${fileName}`, 10, 128);
                            
                            parsedData = {
                                type: 'texture',
                                canvas: canvas,
                                width: 256,
                                height: 256,
                                format: 'DTX',
                                metadata: {
                                    material: 'default',
                                    error: 'Could not parse texture file'
                                }
                            };
                        }
                    } else if (FILE_TYPES.LEVEL.extensions.includes(fileExt)) {
                        parsedData = await LithtechParsers.parseDAT(fileInfo.file);
                    } else if (FILE_TYPES.ARCHIVE.extensions.includes(fileExt)) {
                        console.log(`Processing archive: ${fileName}`);
                        
                        // Check if this is an index file
                        if (fileName === 'packmap_save.lta' || fileName === 'rezmap.lta' || fileName === 'rezmap.ltb') {
                            console.log(`Loading PKB index file: ${fileName}`);
                            // Parse as index file
                            parsedData = await LithtechParsers.parseArchive(fileInfo.file);
                            
                            // Store the raw file data globally for PKB extraction
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                window.MXO_PKB_INDEX_DATA = new Uint8Array(e.target.result);
                                window.MXO_PKB_INDEX_NAME = fileName;
                                console.log(`Stored PKB index data from ${fileName} (${window.MXO_PKB_INDEX_DATA.length} bytes)`);
                            };
                            reader.readAsArrayBuffer(fileInfo.file);
                        } else {
                            parsedData = await LithtechParsers.parseArchive(fileInfo.file);
                        }
                    } else if (FILE_TYPES.MESSAGE.extensions.includes(fileExt)) {
                        parsedData = await LithtechParsers.parseMessage(fileInfo.file);
                    } else if (FILE_TYPES.ASSEMBLY.extensions.includes(fileExt)) {
                        // For DLL and EXE files
                        try {
                            console.log(`Processing assembly: ${fileName}`);
                            parsedData = await LithtechParsers.parseAssembly(fileInfo.file);
                        } catch (error) {
                            console.warn('Error parsing assembly file:', error);
                            alert('Error parsing assembly file. It may not be a valid PE file.');
                            parsedData = { 
                                type: 'binary',
                                metadata: {
                                    format: 'DLL/EXE',
                                    error: 'Could not parse assembly file'
                                }
                            };
                        }
                    } else if (FILE_TYPES.CUTSCENE.extensions.includes(fileExt)) {
                        // For video files, prepare for playback
                        console.log(`Processing video: ${fileName}`);
                        try {
                            // Use the parseCutscene function which handles BIK files
                            parsedData = await LithtechParsers.parseCutscene(fileInfo.file);
                            console.log(`Video processed: ${parsedData.width}x${parsedData.height}, ${parsedData.duration}s`);
                        } catch (error) {
                            console.error('Error processing video:', error);
                            // Fallback if video metadata can't be read
                            const url = URL.createObjectURL(fileInfo.file);
                            parsedData = { 
                                type: 'cutscene', 
                                url,
                                metadata: {
                                    format: fileExt.substring(1).toUpperCase(),
                                    filename: fileName,
                                    error: 'Could not read video metadata'
                                }
                            };
                        }
                    } else if (FILE_TYPES.SCRIPT.extensions.includes(fileExt)) {
                        // For scripts, just read as text
                        console.log(`Processing script: ${fileName}`);
                        const text = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(fileInfo.file);
                        });
                        parsedData = { 
                            type: 'script', 
                            content: text,
                            metadata: {
                                format: fileExt.substring(1).toUpperCase(),
                                filename: fileName
                            }
                        };
                    } else if (FILE_TYPES.SOUND.extensions.includes(fileExt)) {
                        // For audio, create a URL for playback
                        console.log(`Processing audio: ${fileName}`);
                        const url = URL.createObjectURL(fileInfo.file);
                        parsedData = { 
                            type: 'audio', 
                            url,
                            metadata: {
                                format: fileExt.substring(1).toUpperCase(),
                                filename: fileName
                            }
                        };
                    } else {
                        // Default: try to read as text
                        try {
                            const text = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = e => resolve(e.target.result);
                                reader.onerror = reject;
                                reader.readAsText(fileInfo.file);
                            });
                            parsedData = { type: 'text', content: text };
                        } catch (error) {
                            console.warn('Could not read file as text:', error);
                            parsedData = { type: 'binary' };
                        }
                    }
                    
                    setFileData(parsedData);
                } catch (error) {
                    console.error('Error parsing file:', error);
                    alert('Error parsing file. See console for details.');
                } finally {
                    setIsLoading(false);
                }
            };
            
            // Handle extracted files
            const handleExtractedFiles = (extractedFiles) => {
                if (!extractedFiles || extractedFiles.length === 0) return;
                
                // Create a new file tree structure for the extracted files
                const newFiles = { ...files };
                
                // Create "extracted" folder if it doesn't exist
                if (!newFiles['extracted']) {
                    newFiles['extracted'] = {
                        type: 'folder',
                        children: {}
                    };
                }
                
                // Add extracted files to the tree
                extractedFiles.forEach(extractedFile => {
                    const pathParts = extractedFile.path.split('/');
                    let currentLevel = newFiles;
                    
                    // Navigate to the right folder level
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        const part = pathParts[i];
                        if (part === '') continue; // Skip empty parts
                        
                        if (!currentLevel[part]) {
                            currentLevel[part] = {
                                type: 'folder',
                                children: {}
                            };
                        }
                        
                        if (currentLevel[part].type === 'folder') {
                            currentLevel = currentLevel[part].children;
                        } else {
                            // Handle the case where a folder name conflicts with a file name
                            const newFolderName = part + '_folder';
                            currentLevel[newFolderName] = {
                                type: 'folder',
                                children: {}
                            };
                            currentLevel = currentLevel[newFolderName].children;
                        }
                    }
                    
                    // Add the file
                    const fileName = pathParts[pathParts.length - 1];
                    currentLevel[fileName] = {
                        type: 'file',
                        file: extractedFile.file
                    };
                });
                
                // Update the file tree
                setFiles(newFiles);
            };
            
            // Render appropriate editor based on file type
            const renderEditor = () => {
                if (!selectedFile || !fileData) {
                    return (
                        <div className="editor-container p-4 flex items-center justify-center">
                            <div className="text-center">
                                <h3 className="matrix-title text-sm">No File Selected</h3>
                                <p className="text-sm mt-4">
                                    Select a file from the tree to edit
                                </p>
                            </div>
                        </div>
                    );
                }
                
                const fileExt = '.' + selectedFile.name.split('.').pop().toLowerCase();
                
                if (FILE_TYPES.MODEL.extensions.includes(fileExt)) {
                    return <ModelEditor file={selectedFile} data={fileData} />;
                } else if (FILE_TYPES.TEXTURE.extensions.includes(fileExt)) {
                    return <TextureEditor file={selectedFile} data={fileData} />;
                } else if (FILE_TYPES.LEVEL.extensions.includes(fileExt)) {
                    return <LevelEditor file={selectedFile} data={fileData} />;
                } else if (FILE_TYPES.ARCHIVE.extensions.includes(fileExt)) {
                    return <ArchiveViewer 
                        file={selectedFile} 
                        data={fileData} 
                        onFileExtracted={handleExtractedFiles} 
                    />;
                } else if (FILE_TYPES.ASSEMBLY.extensions.includes(fileExt)) {
                    return <AssemblyViewer file={selectedFile} data={fileData} />;
                } else if (FILE_TYPES.SOUND.extensions.includes(fileExt)) {
                    return <AudioEditor file={selectedFile} data={fileData} />;
                } else if (FILE_TYPES.CUTSCENE.extensions.includes(fileExt)) {
                    return <CutsceneViewer file={selectedFile} data={fileData} />;
                } else if (FILE_TYPES.ANIMATION.extensions.includes(fileExt)) {
                    // For animation files, use model editor but set to animation tab
                    return <ModelEditor file={selectedFile} data={{...fileData, initialTab: 'animation'}} />;
                } else {
                    // Default to text editor for scripts, messages, and other text files
                    return (
                        <TextEditor 
                            file={selectedFile} 
                            data={fileData} 
                            onSave={(content) => console.log('Save:', content)}
                        />
                    );
                }
            };
            
            return (
                <div>
                    {/* Header */}
                    <div className="matrix-header">
                        <div className="matrix-title">Matrix Online Modding Suite</div>
                        <div className="flex">
                            <input 
                                type="file" 
                                webkitdirectory="true" 
                                directory="true"
                                style={{ display: 'none' }}
                                id="directory-input"
                                onChange={handleDirectorySelect}
                            />
                            <label htmlFor="directory-input" className="matrix-button">
                                Load Directory
                            </label>
                        </div>
                    </div>
                    
                    {/* Main Navigation */}
                    <div className="border-b border-green-900 bg-black">
                        <div className="flex">
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'explorer' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('explorer')}
                            >
                                File Explorer
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'models' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('models')}
                            >
                                3D Models
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'textures' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('textures')}
                            >
                                Textures
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'audio' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('audio')}
                            >
                                Audio
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'cutscenes' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('cutscenes')}
                            >
                                Cutscenes
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'archives' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('archives')}
                            >
                                Archives
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'gameobjects' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('gameobjects')}
                            >
                                GameObjects
                            </div>
                            <div 
                                className={`px-4 py-2 cursor-pointer ${activeView === 'logs' ? 'bg-green-900 text-green-100' : 'text-green-500'}`}
                                onClick={() => setActiveView('logs')}
                            >
                                Logs
                            </div>
                        </div>
                    </div>
                    
                    {/* Main Content */}
                    {activeView === 'explorer' ? (
                        <div className="flex" style={{ height: 'calc(100vh - 100px)' }}>
                            {/* File Tree */}
                            <div style={{ width: '20%' }}>
                                <FileTree 
                                    files={files}
                                    onFileSelect={handleFileSelect}
                                    selectedFile={selectedFilePath}
                                />
                            </div>
                            
                            {/* Editor Area */}
                            <div style={{ width: '60%' }}>
                                {renderEditor()}
                            </div>
                            
                            {/* Preview/Properties */}
                            <div style={{ width: '20%' }}>
                                <FilePreview file={selectedFile} data={fileData} />
                            </div>
                        </div>
                    ) : activeView === 'models' ? (
                        <div className="p-4" style={{ height: 'calc(100vh - 100px)', overflowY: 'auto' }}>
                            <h3 className="matrix-title mb-4">3D Models Browser</h3>
                            
                            {/* PKB Archive Alert */}
                            <div className="bg-yellow-900 bg-opacity-20 border border-yellow-500 p-3 rounded mb-4">
                                <h4 className="text-sm font-bold mb-1 text-yellow-400">📦 Models are in PKB Archives!</h4>
                                <p className="text-xs mb-2">
                                    Most .moa and .prop files are packed inside .pkb archives in the <strong>packmaps/</strong> directory.
                                </p>
                                <div className="grid grid-cols-2 gap-2 text-xs">
                                    <div>
                                        <strong>Key archives:</strong>
                                        <ul className="list-disc list-inside ml-2">
                                            <li>char_npc.pkb - NPCs</li>
                                            <li>zmisc_1.pkb - Props</li>
                                        </ul>
                                    </div>
                                    <div>
                                        <strong>Index files:</strong>
                                        <ul className="list-disc list-inside ml-2">
                                            <li>packmap_save.lta</li>
                                            <li>rezmap.lta/ltb</li>
                                        </ul>
                                    </div>
                                </div>
                                <div className="flex items-center gap-3 mt-2">
                                    <p className="text-xs text-gray-300">
                                        👉 Go to <strong>Archive Browser</strong> tab to extract models from PKB files.
                                    </p>
                                    <button 
                                        className="px-3 py-1 text-xs border border-yellow-500 bg-yellow-900 bg-opacity-20 hover:bg-opacity-40 text-yellow-400"
                                        onClick={async () => {
                                            // Find all PKB files
                                            const pkbFiles = Object.entries(allFiles).filter(([path]) => 
                                                path.toLowerCase().endsWith('.pkb')
                                            );
                                            
                                            if (pkbFiles.length === 0) {
                                                alert('No PKB archive files found. Please load a directory containing .pkb files from the packmaps/ folder.');
                                                return;
                                            }
                                            
                                            const extractButton = event.target;
                                            extractButton.disabled = true;
                                            extractButton.textContent = 'Extracting...';
                                            
                                            try {
                                                // Extract all model files from PKB archives
                                                let totalExtracted = 0;
                                                
                                                for (const [path, fileInfo] of pkbFiles) {
                                                    const fileName = path.split('/').pop();
                                                    console.log(`Extracting from ${fileName}...`);
                                                    
                                                    // Use the new extraction function
                                                    const extractedFiles = await window.extractFromPKB(fileName);
                                                    
                                                    if (extractedFiles && extractedFiles.length > 0) {
                                                        // Filter for model files
                                                        const modelFiles = extractedFiles.filter(f => {
                                                            const ext = '.' + f.name.split('.').pop().toLowerCase();
                                                            return FILE_TYPES.MODEL.extensions.includes(ext);
                                                        });
                                                        
                                                        // Add extracted files to allFiles
                                                        modelFiles.forEach(extractedFile => {
                                                            const extractedPath = extractedFile.name;
                                                            // Create a File object from the extracted data
                                                            const blob = new Blob([extractedFile.data], { type: 'application/octet-stream' });
                                                            const file = new File([blob], extractedPath.split('/').pop(), {
                                                                lastModified: Date.now()
                                                            });
                                                            
                                                            // Add to allFiles with full path
                                                            allFiles[extractedPath] = {
                                                                type: 'file',
                                                                file: file
                                                            };
                                                        });
                                                        
                                                        totalExtracted += modelFiles.length;
                                                        console.log(`Extracted ${modelFiles.length} model files from ${fileName}`);
                                                    }
                                                }
                                                
                                                // Count extracted model files
                                                let extractedCount = 0;
                                                for (const [path, info] of Object.entries(allFiles)) {
                                                    if (info.file && info.file.name && info.file.name.includes('_info.txt')) {
                                                        continue; // Skip info files
                                                    }
                                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                                    if (FILE_TYPES.MODEL.extensions.includes(ext)) {
                                                        extractedCount++;
                                                    }
                                                }
                                                
                                                // Force a re-render
                                                setAllFiles({...allFiles});
                                                
                                                if (extractedCount === 0) {
                                                    extractButton.textContent = 'No models extracted';
                                                    alert('PKB extraction requires an index file (packmap_save.lta).\n\nTo properly extract models:\n1. First load packmap_save.lta or rezmap.lta\n2. Then use this button to extract from PKB files\n\nWithout the index, PKB files cannot be unpacked.');
                                                } else {
                                                    extractButton.textContent = `Extracted ${extractedCount} models!`;
                                                }
                                                
                                                setTimeout(() => {
                                                    extractButton.textContent = 'Extract All Models';
                                                    extractButton.disabled = false;
                                                }, 3000);
                                                
                                            } catch (error) {
                                                console.error('Error extracting PKB files:', error);
                                                alert('Error extracting files. Check console for details.');
                                                extractButton.textContent = 'Extract All Models';
                                                extractButton.disabled = false;
                                            }
                                        }}
                                    >
                                        Extract All Models
                                    </button>
                                </div>
                            </div>
                            
                            {/* PKB Archive List */}
                            {(() => {
                                const pkbFiles = Object.entries(allFiles).filter(([path]) => 
                                    path.toLowerCase().endsWith('.pkb')
                                );
                                
                                if (pkbFiles.length > 0) {
                                    return (
                                        <div className="mb-4 p-3 border border-blue-500 bg-blue-900 bg-opacity-20">
                                            <h4 className="text-sm font-bold mb-2 text-blue-400">📦 PKB Archives Found ({pkbFiles.length})</h4>
                                            <div className="space-y-2 max-h-48 overflow-y-auto">
                                                {pkbFiles.map(([path, fileInfo]) => {
                                                    const fileName = path.split('/').pop();
                                                    const fileSizeMB = (fileInfo.file.size / 1024 / 1024).toFixed(2);
                                                    
                                                    return (
                                                        <div key={path} className="flex items-center justify-between p-2 bg-black bg-opacity-30 rounded">
                                                            <div className="flex-1">
                                                                <div className="text-sm font-semibold">{fileName}</div>
                                                                <div className="text-xs opacity-70">{fileSizeMB} MB</div>
                                                            </div>
                                                            <button
                                                                className="px-3 py-1 text-xs border border-blue-500 bg-blue-900 bg-opacity-20 hover:bg-opacity-40 text-blue-400"
                                                                onClick={async (e) => {
                                                                    const button = e.target;
                                                                    button.disabled = true;
                                                                    button.textContent = 'Extracting...';
                                                                    
                                                                    try {
                                                                        // Use the new extraction function
                                                                        const extractedFiles = await window.extractFromPKB(fileName);
                                                                        
                                                                        if (extractedFiles && extractedFiles.length > 0) {
                                                                            // Filter for model files
                                                                            const modelFiles = extractedFiles.filter(f => {
                                                                                const ext = '.' + f.name.split('.').pop().toLowerCase();
                                                                                return FILE_TYPES.MODEL.extensions.includes(ext);
                                                                            });
                                                                            
                                                                            // Add extracted files to allFiles
                                                                            modelFiles.forEach(extractedFile => {
                                                                                const extractedPath = extractedFile.name;
                                                                                // Create a File object from the extracted data
                                                                                const blob = new Blob([extractedFile.data], { type: 'application/octet-stream' });
                                                                                const file = new File([blob], extractedPath.split('/').pop(), {
                                                                                    lastModified: Date.now()
                                                                                });
                                                                                
                                                                                // Add to allFiles with full path
                                                                                allFiles[extractedPath] = {
                                                                                    type: 'file',
                                                                                    file: file
                                                                                };
                                                                            });
                                                                            
                                                                            // Force a re-render
                                                                            setAllFiles({...allFiles});
                                                                            
                                                                            if (modelFiles.length === 0) {
                                                                                button.textContent = 'No models';
                                                                                alert(`Found ${extractedFiles.length} files but no models in ${fileName}.\n\nMake sure packmap_save.lta is loaded.`);
                                                                            } else {
                                                                                button.textContent = `${modelFiles.length} models`;
                                                                                alert(`Successfully extracted ${modelFiles.length} model files from ${fileName}!`);
                                                                            }
                                                                            
                                                                            setTimeout(() => {
                                                                                button.textContent = 'Extract & View';
                                                                                button.disabled = false;
                                                                            }, 3000);
                                                                        } else {
                                                                            button.textContent = 'Need Index';
                                                                            alert(`Cannot extract from ${fileName}.\n\nMake sure you have loaded packmap_save.lta first!\n\nThe index file should be in your Matrix Online directory.`);
                                                                            setTimeout(() => {
                                                                                button.textContent = 'Extract & View';
                                                                                button.disabled = false;
                                                                            }, 3000);
                                                                        }
                                                                    } catch (error) {
                                                                        console.error(`Error extracting ${fileName}:`, error);
                                                                        button.textContent = 'Error';
                                                                        setTimeout(() => {
                                                                            button.textContent = 'Extract & View';
                                                                            button.disabled = false;
                                                                        }, 3000);
                                                                    }
                                                                }}
                                                            >
                                                                Extract & View
                                                            </button>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    );
                                }
                                return null;
                            })()}
                            
                            {/* Model Statistics */}
                            <div className="mb-4 p-3 border border-green-500 bg-black bg-opacity-50">
                                <div className="grid grid-cols-3 gap-4 text-sm">
                                    <div>
                                        <span className="text-green-400">Visible Models:</span> {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                            const ext = '.' + path.split('.').pop().toLowerCase();
                                            return FILE_TYPES.MODEL.extensions.includes(ext);
                                        }).length}
                                    </div>
                                    <div>
                                        <span className="text-green-400">MOA Files:</span> {Object.entries(allFiles).filter(([path]) => path.toLowerCase().endsWith('.moa')).length}
                                    </div>
                                    <div>
                                        <span className="text-green-400">PROP Files:</span> {Object.entries(allFiles).filter(([path]) => path.toLowerCase().endsWith('.prop')).length}
                                    </div>
                                </div>
                                <div className="mt-2 text-xs opacity-70">
                                    <div>Expected paths: resource/GameObjects/vehicles/, resource/GameObjects/characters/</div>
                                    <div>Scale: 1 unit = 1 cm (MXO uses Lithtech Discovery engine)</div>
                                </div>
                            </div>
                            
                            {/* Category Filter */}
                            <div className="mb-4">
                                <div className="flex gap-2 flex-wrap">
                                    <button className="px-3 py-1 border border-green-500 hover:bg-green-900 hover:bg-opacity-20" 
                                            onClick={() => setModelFilter('all')}>
                                        All Models
                                    </button>
                                    <button className="px-3 py-1 border border-green-500 hover:bg-green-900 hover:bg-opacity-20" 
                                            onClick={() => setModelFilter('vehicles')}>
                                        Vehicles
                                    </button>
                                    <button className="px-3 py-1 border border-green-500 hover:bg-green-900 hover:bg-opacity-20" 
                                            onClick={() => setModelFilter('characters')}>
                                        Characters
                                    </button>
                                    <button className="px-3 py-1 border border-green-500 hover:bg-green-900 hover:bg-opacity-20" 
                                            onClick={() => setModelFilter('props')}>
                                        Props
                                    </button>
                                </div>
                            </div>
                            
                            <div className="grid grid-cols-3 gap-4">
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    if (!FILE_TYPES.MODEL.extensions.includes(ext)) return false;
                                    
                                    // Apply category filter if set
                                    if (window.modelFilter && window.modelFilter !== 'all') {
                                        if (window.modelFilter === 'vehicles' && !path.includes('vehicles')) return false;
                                        if (window.modelFilter === 'characters' && !path.includes('characters')) return false;
                                        if (window.modelFilter === 'props' && ext !== '.prop') return false;
                                    }
                                    
                                    return true;
                                }).map(([path, fileInfo], index) => {
                                    const fileName = path.split('/').pop();
                                    const ext = '.' + fileName.split('.').pop().toLowerCase();
                                    const isCharacterPart = path.includes('characters') || fileName.includes('body') || fileName.includes('head') || fileName.includes('hand');
                                    
                                    return (
                                        <div 
                                            key={index} 
                                            className="border border-green-500 p-2 cursor-pointer hover:bg-green-900 hover:bg-opacity-20"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                handleFileSelect(path, fileInfo);
                                                setActiveView('explorer'); // Switch to explorer view to show the editor
                                            }}
                                        >
                                            <div className="bg-black bg-opacity-50 aspect-square flex items-center justify-center relative">
                                                <span className="text-4xl">
                                                    {ext === '.moa' ? '🧍' : ext === '.prop' ? '📦' : ext === '.mga' || ext === '.mgc' ? '🎭' : '📊'}
                                                </span>
                                                {isCharacterPart && (
                                                    <span className="absolute top-1 right-1 text-xs bg-green-700 px-1 rounded">CHAR</span>
                                                )}
                                            </div>
                                            <div className="p-2">
                                                <div className="text-center truncate" title={fileName}>
                                                    {fileName}
                                                </div>
                                                <div className="text-xs opacity-70 truncate" title={path}>
                                                    {path.replace(/^.*\/resource\//, 'resource/')}
                                                </div>
                                                <div className="text-xs opacity-50">
                                                    {Math.floor(fileInfo.file.size / 1024)} KB
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.MODEL.extensions.includes(ext);
                                }).length === 0 && (
                                    <div className="col-span-3 text-center p-8">
                                        <div className="mb-4">
                                            <p className="text-lg mb-2">No unpacked 3D model files found</p>
                                            <p className="text-sm opacity-70">Models are packed in PKB archives!</p>
                                        </div>
                                        <div className="text-left max-w-2xl mx-auto p-4 border border-green-500 bg-black bg-opacity-50">
                                            <p className="font-bold mb-2 text-yellow-400">📦 To access Matrix Online models:</p>
                                            <ol className="list-decimal list-inside text-sm space-y-2 mb-3">
                                                <li>Navigate to your MXO <strong>packmaps/</strong> directory</li>
                                                <li>Load <strong>.pkb</strong> archive files</li>
                                                <li>Use the <strong>Archive Browser</strong> tab to extract models</li>
                                            </ol>
                                            <p className="font-bold mb-2">Model file types in archives:</p>
                                            <ul className="list-disc list-inside text-sm space-y-1">
                                                <li><span className="text-green-400">.moa</span> - Character models, clothing, vehicles</li>
                                                <li><span className="text-green-400">.prop</span> - Static props and objects</li>
                                                <li><span className="text-green-400">.abc</span> - Actor Binary Cache files</li>
                                                <li><span className="text-green-400">.iprf/.eprf</span> - Specialized model data</li>
                                                <li><span className="text-green-400">.mga/.mgc</span> - Model group/collection files</li>
                                            </ul>
                                            <p className="mt-3 text-sm">Example paths inside PKB archives:</p>
                                            <ul className="list-disc list-inside text-xs space-y-1 opacity-70">
                                                <li>resource/GameObjects/vehicles/taxi/taxi_white.moa</li>
                                                <li>resource/characters-NPC/Zombie/zombie-f.moa</li>
                                                <li>resource/GameObjects/props/projector_placeholder.prop</li>
                                            </ul>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    ) : activeView === 'textures' ? (
                        <div className="p-4" style={{ height: 'calc(100vh - 100px)', overflowY: 'auto' }}>
                            <h3 className="matrix-title mb-4">Textures Browser</h3>
                            <div className="grid grid-cols-4 gap-4">
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.TEXTURE.extensions.includes(ext);
                                }).map(([path, fileInfo], index) => (
                                    <div 
                                        key={index} 
                                        className="border border-green-500 p-2 cursor-pointer hover:bg-green-900 hover:bg-opacity-20"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            handleFileSelect(path, fileInfo);
                                            setActiveView('explorer'); // Switch to explorer view to show the editor
                                        }}
                                    >
                                        <div className="bg-black bg-opacity-50 aspect-square flex items-center justify-center">
                                            <span className="text-4xl">🖼️</span>
                                        </div>
                                        <div className="p-2 text-center truncate" title={path.split('/').pop()}>
                                            {path.split('/').pop()}
                                        </div>
                                    </div>
                                ))}
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.TEXTURE.extensions.includes(ext);
                                }).length === 0 && (
                                    <div className="col-span-4 text-center p-8">
                                        <p>No texture files found. Load a directory containing .dtx or other image files.</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    ) : activeView === 'audio' ? (
                        <div className="p-4" style={{ height: 'calc(100vh - 100px)', overflowY: 'auto' }}>
                            <h3 className="matrix-title mb-4">Audio Browser</h3>
                            <div className="grid grid-cols-1 gap-2">
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.SOUND.extensions.includes(ext);
                                }).map(([path, fileInfo], index) => (
                                    <div 
                                        key={index} 
                                        className="border border-green-500 p-2 cursor-pointer hover:bg-green-900 hover:bg-opacity-20 flex items-center"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            handleFileSelect(path, fileInfo);
                                            setActiveView('explorer'); // Switch to explorer view to show the editor
                                        }}
                                    >
                                        <span className="text-2xl mr-4">🔊</span>
                                        <div className="flex-grow">
                                            <div className="font-bold">{path.split('/').pop()}</div>
                                            <div className="text-xs opacity-70">{path}</div>
                                        </div>
                                        <div className="text-xs">
                                            {Math.floor(fileInfo.file.size / 1024)} KB
                                        </div>
                                    </div>
                                ))}
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.SOUND.extensions.includes(ext);
                                }).length === 0 && (
                                    <div className="text-center p-8">
                                        <p>No audio files found. Load a directory containing .wav, .ogg, or .mp3 files.</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    ) : activeView === 'cutscenes' ? (
                        <div className="p-4" style={{ height: 'calc(100vh - 100px)', overflowY: 'auto' }}>
                            <h3 className="matrix-title mb-4">Cutscenes Browser</h3>
                            <div className="grid grid-cols-2 gap-4">
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.CUTSCENE.extensions.includes(ext);
                                }).map(([path, fileInfo], index) => (
                                    <div 
                                        key={index} 
                                        className="border border-green-500 p-2 cursor-pointer hover:bg-green-900 hover:bg-opacity-20"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            handleFileSelect(path, fileInfo);
                                            setActiveView('explorer'); // Switch to explorer view to show the editor
                                        }}
                                    >
                                        <div className="bg-black bg-opacity-50 aspect-video flex items-center justify-center">
                                            <span className="text-4xl">🎬</span>
                                        </div>
                                        <div className="p-2">
                                            <div className="font-bold truncate" title={path.split('/').pop()}>
                                                {path.split('/').pop()}
                                            </div>
                                            <div className="flex justify-between text-xs mt-1">
                                                <span>Format: {path.split('.').pop().toUpperCase()}</span>
                                                <span>{Math.floor(fileInfo.file.size / 1024)} KB</span>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.CUTSCENE.extensions.includes(ext);
                                }).length === 0 && (
                                    <div className="col-span-2 text-center p-8">
                                        <p>No cutscene files found. Load a directory containing .bik, .smk, or other video files.</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    ) : activeView === 'archives' ? (
                        <div className="p-4" style={{ height: 'calc(100vh - 100px)', overflowY: 'auto' }}>
                            <h3 className="matrix-title mb-4">Archives Browser</h3>
                            <div className="grid grid-cols-1 gap-2">
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.ARCHIVE.extensions.includes(ext);
                                }).map(([path, fileInfo], index) => (
                                    <div 
                                        key={index} 
                                        className="border border-green-500 p-2 cursor-pointer hover:bg-green-900 hover:bg-opacity-20 flex items-center"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            handleFileSelect(path, fileInfo);
                                            setActiveView('explorer'); // Switch to explorer view to show the editor
                                        }}
                                    >
                                        <span className="text-2xl mr-4">📦</span>
                                        <div className="flex-grow">
                                            <div className="font-bold">{path.split('/').pop()}</div>
                                            <div className="text-xs opacity-70">{path}</div>
                                        </div>
                                        <div className="text-xs">
                                            {Math.floor(fileInfo.file.size / 1024)} KB
                                        </div>
                                    </div>
                                ))}
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.ARCHIVE.extensions.includes(ext);
                                }).length === 0 && (
                                    <div className="text-center p-8">
                                        <p>No archive files found. Load a directory containing .rez, .lta, .ltb, or .pkb files.</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    ) : activeView === 'gameobjects' ? (
                        <GameObjectsAnalyzer allFiles={allFiles} />
                    ) : activeView === 'logs' ? (
                        <div className="p-4" style={{ height: 'calc(100vh - 100px)', overflowY: 'auto' }}>
                            <h3 className="matrix-title mb-4">Log Files Browser</h3>
                            <div className="grid grid-cols-1 gap-2">
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.LOG.extensions.includes(ext) || 
                                           path.toLowerCase().includes('log') ||
                                           path.toLowerCase().includes('debug');
                                }).map(([path, fileInfo], index) => (
                                    <div 
                                        key={index} 
                                        className="border border-green-500 p-2 cursor-pointer hover:bg-green-900 hover:bg-opacity-20 flex items-center"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            handleFileSelect(path, fileInfo);
                                            setActiveView('explorer'); // Switch to explorer view to show the editor
                                        }}
                                    >
                                        <span className="text-2xl mr-4">📋</span>
                                        <div className="flex-grow">
                                            <div className="font-bold">{path.split('/').pop()}</div>
                                            <div className="text-xs opacity-70">{path}</div>
                                        </div>
                                        <div className="text-xs">
                                            {Math.floor(fileInfo.file.size / 1024)} KB
                                        </div>
                                    </div>
                                ))}
                                {Object.entries(allFiles).filter(([path, fileInfo]) => {
                                    const ext = '.' + path.split('.').pop().toLowerCase();
                                    return FILE_TYPES.LOG.extensions.includes(ext) || 
                                           path.toLowerCase().includes('log') ||
                                           path.toLowerCase().includes('debug');
                                }).length === 0 && (
                                    <div className="text-center p-8">
                                        <p>No log files found. Load a directory containing .log, .txt, .out, or debug files.</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    ) : null}
                    
                    {/* Loading Overlay */}
                    {isLoading && (
                        <div className="loading-matrix">
                            <canvas id="matrix-rain-overlay" className="matrix-rain"></canvas>
                            <div className="loading-text">Processing...</div>
                        </div>
                    )}
                </div>
            );
        };
        
        // Matrix rain animation
        function setupMatrixRain() {
            const canvas = document.getElementById('matrix-rain');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const columns = Math.floor(canvas.width / 20);
            const drops = [];
            
            for (let i = 0; i < columns; i++) {
                drops[i] = Math.floor(Math.random() * canvas.height);
            }
            
            function drawMatrixRain() {
                ctx.fillStyle = 'rgba(0, 8, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '15px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = String.fromCharCode(0x30A0 + Math.floor(Math.random() * 95));
                    ctx.fillText(text, i * 20, drops[i] * 20);
                    
                    if (drops[i] * 20 > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            
            return setInterval(drawMatrixRain, 50);
        }
        
        // Initialize the app
        const initApp = () => {
            // Start the Matrix rain animation
            const matrixInterval = setupMatrixRain();
            
            // Wait for THREE.js to be ready
            const waitForThree = () => {
                if (window.THREE && window.THREE.OrbitControls) {
                    console.log('THREE.js is ready, initializing app');
                    
                    // Simulate loading time (2 seconds)
                    setTimeout(() => {
                        // Hide the loading screen
                        document.getElementById('loading').style.display = 'none';
                        
                        // Render the React app
                        ReactDOM.render(
                            <App />,
                            document.getElementById('root')
                        );
                        
                        // Clean up matrix rain animation
                        clearInterval(matrixInterval);
                    }, 2000);
                } else {
                    console.log('Waiting for THREE.js...');
                    setTimeout(waitForThree, 100);
                }
            };
            
            waitForThree();
        };
        
        // Start the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
    </script>
</body>
</html>